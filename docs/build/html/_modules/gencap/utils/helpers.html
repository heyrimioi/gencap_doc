

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>gencap.utils.helpers &mdash; GENCAP 0.9.0-dev documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=6c04cfde"></script>
      <script src="../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            GENCAP
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">üõ†Ô∏è API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../modules.html">gencap</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">GENCAP</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">gencap.utils.helpers</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for gencap.utils.helpers</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span><span class="w"> </span><span class="nn">copy</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">glob</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">json</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">Counter</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">psutil</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">networkx</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nx</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">plotly.graph_objects</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">go</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">matplotlib.lines</span><span class="w"> </span><span class="kn">import</span> <span class="n">Line2D</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">networkx.drawing.nx_agraph</span><span class="w"> </span><span class="kn">import</span> <span class="n">graphviz_layout</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.config</span><span class="w"> </span><span class="kn">import</span> <span class="n">load_path_cache</span><span class="p">,</span><span class="n">save_path_cache</span>
<span class="c1"># -------------------------------------------------------------------------</span>
<span class="c1"># shared helpers</span>
<span class="c1"># -------------------------------------------------------------------------</span>

<span class="c1"># ----------------- Path related helpers ------------------</span>
<div class="viewcode-block" id="deduplicate_paths">
<a class="viewcode-back" href="../../../gencap.utils.html#gencap.utils.helpers.deduplicate_paths">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">deduplicate_paths</span><span class="p">(</span><span class="n">path_list</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Remove redundant paths that refer to the same underlying file or directory.</span>

<span class="sd">    This function uses ``os.path.samefile`` to detect and remove duplicate paths </span>
<span class="sd">    that resolve to the same physical file or directory (e.g., symbolic links </span>
<span class="sd">    pointing to the same target).</span>

<span class="sd">    Args:</span>
<span class="sd">        path_list (list[str]): </span>
<span class="sd">            List of file or directory paths.</span>

<span class="sd">    Returns:</span>
<span class="sd">        list[str]: </span>
<span class="sd">            Deduplicated list containing one path per unique physical file/directory.</span>

<span class="sd">    Notes:</span>
<span class="sd">        * Non-existing paths are skipped silently.</span>
<span class="sd">        * Any errors during resolution are caught, and warnings are printed.</span>
<span class="sd">    </span>
<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; paths = [&quot;/data/dataset1&quot;, &quot;/mnt/link_to_dataset1&quot;]</span>
<span class="sd">        &gt;&gt;&gt; deduplicate_paths(paths)</span>
<span class="sd">        [&#39;/data/dataset1&#39;]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">unique_paths</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">seen</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">path_list</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Check against all already included real files</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">samefile</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">existing</span><span class="p">)</span> <span class="k">for</span> <span class="n">existing</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="n">seen</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
            <span class="n">unique_paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">FileNotFoundError</span><span class="p">:</span>
            <span class="c1"># Skip non-existing paths</span>
            <span class="k">continue</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[Warning] Could not process path: </span><span class="si">{</span><span class="n">path</span><span class="si">}</span><span class="s2">. Reason: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">continue</span>

    <span class="k">return</span> <span class="n">unique_paths</span></div>


<div class="viewcode-block" id="make_key">
<a class="viewcode-back" href="../../../gencap.utils.html#gencap.utils.helpers.make_key">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">make_key</span><span class="p">(</span><span class="n">databaseDir</span><span class="p">,</span> <span class="n">datasetName</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate a unique cache key for a dataset path search.</span>

<span class="sd">    Args:</span>
<span class="sd">        databaseDir (str): </span>
<span class="sd">            Absolute path to the dataset database root directory.</span>
<span class="sd">        datasetName (str): </span>
<span class="sd">            Name of the dataset.</span>
<span class="sd">        prefix (str, optional): </span>
<span class="sd">            Optional prefix string to include in the key.</span>

<span class="sd">    Returns:</span>
<span class="sd">        str: MD5 hash string representing a unique key for the given inputs.</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; make_key(&quot;/data&quot;, &quot;my_dataset&quot;, prefix=&quot;study&quot;)</span>
<span class="sd">        &#39;5d41402abc4b2a76b9719d911017c592&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">hashlib</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
    <span class="n">key_string</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">databaseDir</span><span class="p">)</span><span class="si">}</span><span class="s2">::</span><span class="si">{</span><span class="n">datasetName</span><span class="si">}</span><span class="s2">::</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="k">return</span> <span class="n">hashlib</span><span class="o">.</span><span class="n">md5</span><span class="p">(</span><span class="n">key_string</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span></div>


<div class="viewcode-block" id="find_dataset_path">
<a class="viewcode-back" href="../../../gencap.utils.html#gencap.utils.helpers.find_dataset_path">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">find_dataset_path</span><span class="p">(</span><span class="n">datasetName</span><span class="p">,</span> <span class="n">databaseDir</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Locate a dataset directory or JSON file by name within a database directory.</span>

<span class="sd">    This function searches recursively for:</span>
<span class="sd">      * A directory matching the dataset name.</span>
<span class="sd">      * A ``.json`` file with the same dataset name.</span>

<span class="sd">    It also leverages a path cache to speed up repeated lookups.</span>

<span class="sd">    Args:</span>
<span class="sd">        datasetName (str): </span>
<span class="sd">            Name of the dataset (without extension).</span>
<span class="sd">        databaseDir (str, optional): </span>
<span class="sd">            Root directory for dataset search. </span>
<span class="sd">            If None, uses ``GENCAP_DATABASE_DIR`` environment variable or falls back to the home directory.</span>

<span class="sd">    Returns:</span>
<span class="sd">        str or None:</span>
<span class="sd">            - Absolute path to the matched dataset directory or JSON file if exactly one match is found.</span>
<span class="sd">            - None if no matches are found.</span>

<span class="sd">    Raises:</span>
<span class="sd">        RuntimeError:</span>
<span class="sd">            If multiple matches are found for the same dataset name.</span>

<span class="sd">    Notes:</span>
<span class="sd">        * Results are cached to avoid redundant filesystem scans.</span>
<span class="sd">        * Uses ``deduplicate_paths`` to remove symbolic path duplicates.</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; find_dataset_path(&quot;dataset1&quot;, databaseDir=&quot;/data&quot;)</span>
<span class="sd">        &#39;/data/study1/dataset1&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check if user defined a custom path</span>
    <span class="k">if</span> <span class="n">databaseDir</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">user_defined_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getenv</span><span class="p">(</span><span class="s2">&quot;GENCAP_DATABASE_DIR&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">user_defined_path</span><span class="p">:</span>
            <span class="n">databaseDir</span> <span class="o">=</span> <span class="n">user_defined_path</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">databaseDir</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">(</span><span class="s2">&quot;~&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;databaseDir was not assigned. search the dataset from home directory. Configured home directory: [</span><span class="si">{</span><span class="n">databaseDir</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">)</span>

    <span class="c1"># load cache</span>
    <span class="n">cache</span> <span class="o">=</span> <span class="n">load_path_cache</span><span class="p">()</span>
    <span class="n">key</span> <span class="o">=</span> <span class="n">make_key</span><span class="p">(</span><span class="n">databaseDir</span><span class="p">,</span> <span class="n">datasetName</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">cache</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">cache</span><span class="p">[</span><span class="n">key</span><span class="p">]):</span>
        <span class="n">matched_paths</span> <span class="o">=</span> <span class="n">cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">matched_paths</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Search directories matching datasetName</span>
        <span class="n">dir_candidates</span> <span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">databaseDir</span><span class="p">,</span> <span class="s2">&quot;**&quot;</span><span class="p">,</span> <span class="n">datasetName</span><span class="p">),</span> <span class="n">recursive</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">matched_dirs</span> <span class="o">=</span> <span class="p">[</span><span class="n">path</span> <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">dir_candidates</span> <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="ow">and</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="o">==</span> <span class="n">datasetName</span><span class="p">]</span>

        <span class="c1"># Search files matching datasetName.json</span>
        <span class="n">file_candidates</span> <span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">databaseDir</span><span class="p">,</span> <span class="s2">&quot;**&quot;</span><span class="p">,</span> <span class="n">datasetName</span> <span class="o">+</span> <span class="s2">&quot;.json&quot;</span><span class="p">),</span> <span class="n">recursive</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">matched_files</span> <span class="o">=</span> <span class="p">[</span><span class="n">path</span> <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">file_candidates</span> <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="ow">and</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="o">==</span> <span class="n">datasetName</span> <span class="o">+</span> <span class="s2">&quot;.json&quot;</span><span class="p">]</span>

        <span class="n">matched_paths</span> <span class="o">=</span> <span class="n">matched_dirs</span> <span class="o">+</span> <span class="n">matched_files</span>
        <span class="n">matched_paths</span> <span class="o">=</span> <span class="n">deduplicate_paths</span><span class="p">(</span><span class="n">matched_paths</span><span class="p">)</span> <span class="c1"># remove the duplicated symbolic path if they are refering same original path.</span>

        <span class="k">if</span> <span class="n">matched_paths</span><span class="p">:</span>
            <span class="n">cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">matched_paths</span>
            <span class="n">save_path_cache</span><span class="p">(</span><span class="n">cache</span><span class="p">)</span>


    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">matched_paths</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">matched_paths</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">matched_paths</span><span class="p">)</span> <span class="o">==</span><span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[find_dataset_path] Multiple paths found: </span><span class="si">{</span><span class="n">matched_paths</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="find_dataset_path_with_prefix">
<a class="viewcode-back" href="../../../gencap.utils.html#gencap.utils.helpers.find_dataset_path_with_prefix">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">find_dataset_path_with_prefix</span><span class="p">(</span><span class="n">datasetName</span><span class="p">,</span> <span class="n">databaseDir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Search for dataset directories matching a prefix pattern.</span>

<span class="sd">    This function looks for directories with names following these patterns:</span>
<span class="sd">        * ``&lt;prefix&gt;-&lt;datasetName&gt;``</span>
<span class="sd">        * ``&lt;prefix&gt;#*-&lt;datasetName&gt;`` (multi-version format)</span>

<span class="sd">    Args:</span>
<span class="sd">        datasetName (str): </span>
<span class="sd">            Base name of the dataset.</span>
<span class="sd">        databaseDir (str, optional): </span>
<span class="sd">            Root directory to search. Defaults to the home directory if None.</span>
<span class="sd">        prefix (str): </span>
<span class="sd">            Prefix string used for naming datasets (e.g., study IDs).</span>

<span class="sd">    Returns:</span>
<span class="sd">        list[str]: </span>
<span class="sd">            List of matched dataset directory paths. Empty if no matches are found.</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; find_dataset_path_with_prefix(&quot;dataset1&quot;, databaseDir=&quot;/data&quot;, prefix=&quot;study&quot;)</span>
<span class="sd">        [&#39;/data/study-study1-dataset1&#39;]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">databaseDir</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">databaseDir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">(</span><span class="s2">&quot;~&quot;</span><span class="p">)</span>
        
    <span class="c1"># Define search patterns</span>
    <span class="n">patterns</span> <span class="o">=</span> <span class="p">[</span>
        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">datasetName</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>                      <span class="c1"># normal pattern</span>
        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">#*-</span><span class="si">{</span><span class="n">datasetName</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>                    <span class="c1"># multiple versions pattern</span>
    <span class="p">]</span>

    <span class="n">matched_paths</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">pattern</span> <span class="ow">in</span> <span class="n">patterns</span><span class="p">:</span>
        <span class="n">glob_pattern</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">databaseDir</span><span class="p">,</span> <span class="s2">&quot;**&quot;</span><span class="p">,</span> <span class="n">pattern</span><span class="p">)</span>
        <span class="n">candidates</span> <span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">glob_pattern</span><span class="p">,</span> <span class="n">recursive</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># Only keep directories (not files)</span>
        <span class="n">matched_paths</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">path</span> <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">candidates</span> <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">path</span><span class="p">)])</span>


    <span class="k">return</span> <span class="n">matched_paths</span></div>


<span class="c1"># ----------------- Dataset graph related helpers ------------------</span>
<div class="viewcode-block" id="build_dependency_graph_dataset">
<a class="viewcode-back" href="../../../gencap.utils.html#gencap.utils.helpers.build_dependency_graph_dataset">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">build_dependency_graph_dataset</span><span class="p">(</span><span class="n">dataset_dir</span><span class="p">,</span> <span class="n">database_dir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_level</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">graph</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Build a directed graph representing dataset dependencies within GENCAP.</span>

<span class="sd">    This function traces the pipeline tree of a dataset (using :func:`trace_pipeline_tree`)</span>
<span class="sd">    and constructs a NetworkX directed graph where:</span>
<span class="sd">    </span>
<span class="sd">    * Nodes represent datasets (raw data, intermediate derivatives, or final outputs).</span>
<span class="sd">    * Edges represent pipeline operations linking datasets.</span>

<span class="sd">    Args:</span>
<span class="sd">        dataset_dir (str or list): </span>
<span class="sd">            Path (or list of paths) to the target dataset directory (final dataset or intermediate).</span>
<span class="sd">        database_dir (str, optional): </span>
<span class="sd">            Root directory containing the dataset database.</span>
<span class="sd">            If not provided, it is inferred from the dataset path.</span>
<span class="sd">        n_level (int, optional): </span>
<span class="sd">            Depth of traversal in the dependency graph.</span>
<span class="sd">            ``-1`` (default) traverses all levels.</span>
<span class="sd">        logger (logging.Logger, optional): </span>
<span class="sd">            Logger instance for logging progress.</span>
<span class="sd">        graph (nx.DiGraph, optional): </span>
<span class="sd">            Existing graph to append to. If None, creates a new graph.</span>

<span class="sd">    Returns:</span>
<span class="sd">        networkx.DiGraph: </span>
<span class="sd">            A directed graph with:</span>
<span class="sd">              - Nodes labeled by dataset ID and annotated with ``ntype`` (raw_data, derivatives, Output).</span>
<span class="sd">              - Edges labeled with pipeline ID and version.</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; G = build_dependency_graph_dataset(&quot;/data/derivatives/final_dataset&quot;)</span>
<span class="sd">        &gt;&gt;&gt; print(G.nodes())</span>
<span class="sd">        [&#39;raw_dataset1&#39;, &#39;raw_dataset2&#39;, &#39;intermediate1&#39;, &#39;final_dataset&#39;]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">json</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
    
    <span class="n">traced_dict</span> <span class="o">=</span> <span class="n">trace_pipeline_tree</span><span class="p">(</span><span class="n">dataset_dir</span><span class="p">,</span> <span class="n">database_dir</span><span class="p">,</span><span class="n">n_level</span><span class="p">,</span><span class="n">logger</span><span class="o">=</span><span class="n">logger</span><span class="p">)</span>
    
    <span class="c1"># Initialize or copy existing graph</span>
    <span class="k">if</span> <span class="n">graph</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
        
        
    <span class="c1"># === Step 1: Add nodes based on levels ===</span>
    <span class="k">for</span> <span class="n">lev</span><span class="p">,</span> <span class="n">data_list</span> <span class="ow">in</span> <span class="n">traced_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">lev</span> <span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">data_list</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;dataset_id&quot;</span><span class="p">],</span> <span class="n">ntype</span><span class="o">=</span><span class="s2">&quot;Output&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">lev</span> <span class="o">==</span><span class="s2">&quot;raw_data&quot;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">dataset</span> <span class="ow">in</span> <span class="n">data_list</span><span class="p">:</span>
                <span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">dataset</span><span class="p">[</span><span class="s2">&quot;dataset_id&quot;</span><span class="p">],</span> <span class="n">ntype</span><span class="o">=</span><span class="s2">&quot;raw_data&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">dataset</span> <span class="ow">in</span> <span class="n">data_list</span><span class="p">:</span>
                <span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">dataset</span><span class="p">[</span><span class="s2">&quot;dataset_id&quot;</span><span class="p">],</span> <span class="n">ntype</span><span class="o">=</span><span class="s2">&quot;derivatives&quot;</span><span class="p">)</span>
                
        <span class="c1"># If limited depth specified, include unlisted dependencies</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">n_level</span> <span class="o">!=-</span><span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">lev</span><span class="o">==</span> <span class="n">n_level</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">data_list</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">src</span> <span class="ow">in</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;cohortDatasetList&quot;</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">src</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;dataset_id&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">traced_dict</span><span class="p">[</span><span class="s2">&quot;raw_data&quot;</span><span class="p">]]:</span>
                        <span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">ntype</span><span class="o">=</span><span class="s2">&quot;derivatives&quot;</span><span class="p">)</span>
                        
    <span class="c1"># === Step 2: Add edges (pipelines) ===</span>
    <span class="k">for</span> <span class="n">level</span><span class="p">,</span> <span class="n">data_list</span> <span class="ow">in</span> <span class="n">traced_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">level</span> <span class="o">!=</span> <span class="s2">&quot;raw_data&quot;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">dataset</span> <span class="ow">in</span> <span class="n">data_list</span><span class="p">:</span>
                <span class="n">tgt</span> <span class="o">=</span> <span class="n">dataset</span><span class="p">[</span><span class="s2">&quot;dataset_id&quot;</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">src</span> <span class="ow">in</span> <span class="n">dataset</span><span class="p">[</span><span class="s2">&quot;cohortDatasetList&quot;</span><span class="p">]:</span>
                    <span class="n">label</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;&lt;b&gt;Pipeline ID&lt;/b&gt;: </span><span class="si">{</span><span class="n">dataset</span><span class="p">[</span><span class="s1">&#39;pipelineID&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&lt;br&gt;&lt;b&gt;Version&lt;/b&gt;: </span><span class="si">{</span><span class="n">dataset</span><span class="p">[</span><span class="s1">&#39;pipelineVersion&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">tgt</span><span class="p">,</span> <span class="n">pipelineID</span><span class="o">=</span><span class="n">dataset</span><span class="p">[</span><span class="s2">&quot;pipelineID&quot;</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">)</span>
                    
    <span class="k">return</span> <span class="n">G</span></div>


<div class="viewcode-block" id="trace_pipeline_tree">
<a class="viewcode-back" href="../../../gencap.utils.html#gencap.utils.helpers.trace_pipeline_tree">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">trace_pipeline_tree</span><span class="p">(</span><span class="n">dataset_dir</span><span class="p">,</span> <span class="n">database_dir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_level</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">summary</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Trace the dataset reproduction tree by following its pipeline lineage.</span>

<span class="sd">    This function recursively traverses dataset dependencies using their ``data_source.json`` files</span>
<span class="sd">    and constructs a hierarchical lineage (tree) showing the datasets and their source cohorts.</span>

<span class="sd">    Args:</span>
<span class="sd">        dataset_dir (str or list): </span>
<span class="sd">            Path (or list of paths) to the starting dataset directory (final or intermediate).</span>
<span class="sd">        database_dir (str, optional): </span>
<span class="sd">            Root database directory containing all datasets. </span>
<span class="sd">            Defaults to the parent directory above ``derivatives``.</span>
<span class="sd">        n_level (int, optional): </span>
<span class="sd">            Maximum depth of tracing (``-1`` for unlimited depth).</span>
<span class="sd">        summary (bool, optional): </span>
<span class="sd">            If True, returns only dataset IDs per level.</span>
<span class="sd">        logger (logging.Logger, optional): </span>
<span class="sd">            Logger instance for progress reporting.</span>

<span class="sd">    Returns:</span>
<span class="sd">        dict:</span>
<span class="sd">            A mapping of levels to lists of dataset details. Each dataset entry includes:</span>
<span class="sd">            * ``dataset_dir``: Absolute path to the dataset.</span>
<span class="sd">            * ``dataset_id``: Dataset folder name.</span>
<span class="sd">            * ``cohortDatasetList``: List of source datasets.</span>
<span class="sd">            * ``pipelineID``: Associated pipeline ID.</span>
<span class="sd">            * ``pipelineVersion``: Pipeline version.</span>

<span class="sd">            If ``summary=True``, maps levels to lists of dataset IDs only.</span>

<span class="sd">    Raises:</span>
<span class="sd">        FileNotFoundError:</span>
<span class="sd">            If a dataset listed in ``cohortDatasetList`` cannot be located.</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; trace_pipeline_tree(&quot;/data/derivatives/final_dataset&quot;, summary=True)</span>
<span class="sd">        {</span>
<span class="sd">            1: [&#39;final_dataset&#39;],</span>
<span class="sd">            2: [&#39;intermediate1&#39;],</span>
<span class="sd">            &#39;raw_data&#39;: [&#39;raw_dataset1&#39;, &#39;raw_dataset2&#39;]</span>
<span class="sd">        }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">find_dataset_dir_from_list</span><span class="p">(</span><span class="n">dataset_list</span><span class="p">,</span><span class="n">database_dir</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Resolve dataset names to their directories using find_dataset_path.&quot;&quot;&quot;</span>
        <span class="n">path_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">path_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">dataset</span> <span class="ow">in</span> <span class="n">dataset_list</span><span class="p">:</span>
            <span class="n">path</span> <span class="o">=</span> <span class="n">find_dataset_path</span><span class="p">(</span><span class="n">datasetName</span><span class="o">=</span><span class="n">dataset</span><span class="p">,</span><span class="n">databaseDir</span><span class="o">=</span><span class="n">database_dir</span><span class="p">)</span>
            <span class="n">path_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">path_list</span><span class="p">)</span><span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dataset_list</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">FileNotFoundError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Dataset </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">dataset_list</span><span class="p">)</span><span class="o">-</span><span class="nb">set</span><span class="p">(</span><span class="n">path_list</span><span class="p">))</span><span class="si">}</span><span class="s2"> can not be found.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">path_list</span>
    
    <span class="c1"># Default database_dir inferred from path</span>
    <span class="k">if</span> <span class="n">database_dir</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">database_dir</span> <span class="o">=</span> <span class="n">dataset_dir</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;derivatives&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    
    <span class="c1"># Logging start</span>
    <span class="k">if</span> <span class="n">logger</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Tracing the dataset reproduction tree...&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Tracing the dataset reproduction tree...&quot;</span><span class="p">)</span>
    <span class="n">traced_all</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">traced_all</span><span class="p">[</span><span class="s2">&quot;raw_data&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">count</span><span class="o">=</span> <span class="mi">1</span>
    <span class="n">visited_dirs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="n">current_dirs</span> <span class="o">=</span> <span class="n">dataset_dir</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dataset_dir</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="k">else</span> <span class="p">[</span><span class="n">dataset_dir</span><span class="p">]</span>

    <span class="k">while</span> <span class="n">current_dirs</span><span class="p">:</span>
        <span class="n">next_dirs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">traced_all</span><span class="p">[</span><span class="n">count</span><span class="p">]</span><span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">datasetDir</span> <span class="ow">in</span> <span class="n">current_dirs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">datasetDir</span> <span class="ow">in</span> <span class="n">visited_dirs</span><span class="p">:</span>
                <span class="k">continue</span>  <span class="c1"># avoid infinite loops</span>
            <span class="k">if</span> <span class="n">datasetDir</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">visited_dirs</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">datasetDir</span><span class="p">)</span>
                
                <span class="c1"># Handle raw_data nodes</span>
                <span class="k">if</span> <span class="s2">&quot;raw_data&quot;</span> <span class="ow">in</span> <span class="n">datasetDir</span><span class="p">:</span>
                    <span class="n">foundRawData</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;dataset_dir&quot;</span><span class="p">:</span> <span class="n">datasetDir</span><span class="p">,</span><span class="s2">&quot;dataset_id&quot;</span><span class="p">:</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">datasetDir</span><span class="p">)}</span>
                    <span class="n">traced_all</span><span class="p">[</span><span class="s2">&quot;raw_data&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">foundRawData</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">summary</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">True</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">logger</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Reached raw_data: </span><span class="si">{</span><span class="n">datasetDir</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Reached raw_data: </span><span class="si">{</span><span class="n">datasetDir</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="k">continue</span>
                    
                <span class="c1"># Stop tracing if max depth reached</span>
                <span class="k">if</span> <span class="n">n_level</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">count</span> <span class="o">==</span> <span class="n">n_level</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span>
                    <span class="k">break</span>
                
                <span class="c1"># Parse data_source.json</span>
                <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">datasetDir</span><span class="p">,</span> <span class="s2">&quot;data_source.json&quot;</span><span class="p">),</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
                
                <span class="n">foundData</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s2">&quot;dataset_dir&quot;</span><span class="p">:</span> <span class="n">datasetDir</span><span class="p">,</span>
                    <span class="s2">&quot;dataset_id&quot;</span><span class="p">:</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">datasetDir</span><span class="p">),</span>
                    <span class="s2">&quot;cohortDatasetList&quot;</span><span class="p">:</span> <span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;cohortDatasetList&quot;</span><span class="p">),</span>
                    <span class="s2">&quot;pipelineID&quot;</span><span class="p">:</span> <span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;pipelineID&quot;</span><span class="p">),</span>
                    <span class="s2">&quot;pipelineVersion&quot;</span><span class="p">:</span> <span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;pipelineVersion&quot;</span><span class="p">),</span>
                <span class="p">}</span>
                <span class="n">traced_all</span><span class="p">[</span><span class="n">count</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">foundData</span><span class="p">)</span>
                
                <span class="c1"># Recursively trace cohort datasets</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="c1"># find new dataset dirs from source list</span>
                    <span class="n">found_dirs</span> <span class="o">=</span> <span class="n">find_dataset_dir_from_list</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;cohortDatasetList&quot;</span><span class="p">],</span> <span class="n">database_dir</span><span class="p">)</span>
                    <span class="n">next_dirs</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">found_dirs</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">logger</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error while finding source dirs: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error while finding source dirs: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="k">continue</span>

        <span class="n">current_dirs</span> <span class="o">=</span> <span class="n">next_dirs</span>
        <span class="k">if</span> <span class="n">traced_all</span><span class="p">[</span><span class="n">count</span><span class="p">]:</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">traced_all</span><span class="p">[</span><span class="n">count</span><span class="p">]</span>
            <span class="k">break</span>

    <span class="k">if</span> <span class="n">summary</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="c1"># Convert to IDs only if summary mode enabled</span>
        <span class="n">traced_all</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="p">[</span><span class="n">item</span><span class="p">[</span><span class="s2">&quot;dataset_id&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">value</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">traced_all</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
    <span class="k">return</span> <span class="n">traced_all</span></div>


<div class="viewcode-block" id="visualize_graph_dataset">
<a class="viewcode-back" href="../../../gencap.utils.html#gencap.utils.helpers.visualize_graph_dataset">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">visualize_graph_dataset</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">return_fig</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">nicePlots</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Visualize the dataset dependency graph.</span>

<span class="sd">    This function renders a directed acyclic graph (DAG) of dataset dependencies created </span>
<span class="sd">    by :func:`build_dependency_graph_dataset` using either:</span>
<span class="sd">    </span>
<span class="sd">    * **Plotly** (if ``nicePlots=True``): Interactive visualization.</span>
<span class="sd">    * **Matplotlib** (default): Static diagram.</span>

<span class="sd">    Args:</span>
<span class="sd">        graph (networkx.DiGraph): </span>
<span class="sd">            Dataset dependency graph generated by :func:`build_dependency_graph_dataset`.</span>
<span class="sd">        return_fig (bool, optional): </span>
<span class="sd">            If True, returns the Plotly or Matplotlib figure object.</span>
<span class="sd">        nicePlots (bool, optional): </span>
<span class="sd">            If True, uses Plotly for interactive visualization. Otherwise, uses Matplotlib.</span>
<span class="sd">        show (bool, optional): </span>
<span class="sd">            If True (default), displays the figure immediately.</span>
<span class="sd">        logger (logging.Logger, optional): </span>
<span class="sd">            Logger instance for logging messages.</span>

<span class="sd">    Returns:</span>
<span class="sd">        plotly.graph_objects.Figure or matplotlib.figure.Figure:</span>
<span class="sd">            The rendered figure if ``return_fig=True``.</span>

<span class="sd">    Notes:</span>
<span class="sd">        * Raw datasets are green circles.</span>
<span class="sd">        * Intermediate derivatives are orange squares.</span>
<span class="sd">        * Final datasets are blue stars.</span>
<span class="sd">        * Edges display pipeline IDs and versions.</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; G = build_dependency_graph_dataset(&quot;/data/derivatives/final_dataset&quot;)</span>
<span class="sd">        &gt;&gt;&gt; visualize_graph_dataset(G, nicePlots=True)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">logger</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Drawing dataset graph...&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Drawing dataset graph...&quot;</span><span class="p">)</span>
        
    <span class="n">G</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
    <span class="n">exec_order</span> <span class="o">=</span> <span class="n">get_sorted_execution_order</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>

    <span class="c1"># Node layout with Graphviz </span>
    <span class="n">pos</span> <span class="o">=</span> <span class="n">graphviz_layout</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">prog</span><span class="o">=</span><span class="s2">&quot;dot&quot;</span><span class="p">)</span>
    
    <span class="c1"># === Plotly interactive visualization ===</span>
    <span class="k">if</span> <span class="n">nicePlots</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="c1"># ‚îÄ‚îÄ Step 1: Process edges ‚îÄ‚îÄ</span>
        <span class="n">edge_x</span><span class="p">,</span> <span class="n">edge_y</span><span class="p">,</span><span class="n">label_x</span><span class="p">,</span> <span class="n">label_y</span><span class="p">,</span> <span class="n">edge_labels</span><span class="p">,</span><span class="n">edge_text</span><span class="p">,</span> <span class="n">annotations</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],[],[]</span>
        <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">edata</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="n">x0</span><span class="p">,</span> <span class="n">y0</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="n">u</span><span class="p">]</span>
            <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>

            <span class="c1"># Collect edge line coordinates</span>
            <span class="n">edge_x</span> <span class="o">+=</span> <span class="p">[</span><span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
            <span class="n">edge_y</span> <span class="o">+=</span> <span class="p">[</span><span class="n">y0</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>

            <span class="c1"># Compute midpoint for edge label</span>
            <span class="n">mx</span><span class="p">,</span> <span class="n">my</span> <span class="o">=</span> <span class="p">(</span><span class="n">x0</span> <span class="o">+</span> <span class="n">x1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="n">y0</span> <span class="o">+</span> <span class="n">y1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="n">label_x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mx</span><span class="p">)</span>
            <span class="n">label_y</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">my</span><span class="p">)</span>
            <span class="n">edge_labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edata</span><span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">])</span>
            <span class="n">edge_text</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edata</span><span class="p">[</span><span class="s2">&quot;pipelineID&quot;</span><span class="p">])</span>

            <span class="c1"># Create arrow annotation from source to target node</span>
            <span class="n">annotations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">x0</span><span class="p">,</span> <span class="n">ay</span><span class="o">=</span><span class="n">y0</span><span class="p">,</span><span class="n">x</span><span class="o">=</span><span class="n">x1</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">y1</span><span class="p">,</span><span class="n">axref</span><span class="o">=</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">ayref</span><span class="o">=</span><span class="s2">&quot;y&quot;</span><span class="p">,</span><span class="n">xref</span><span class="o">=</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">yref</span><span class="o">=</span><span class="s2">&quot;y&quot;</span><span class="p">,</span>
                <span class="n">showarrow</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">arrowhead</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span><span class="n">arrowsize</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">arrowwidth</span><span class="o">=</span><span class="mf">1.5</span><span class="p">,</span><span class="n">arrowcolor</span><span class="o">=</span><span class="s2">&quot;gray&quot;</span><span class="p">))</span>

        <span class="c1"># ‚îÄ‚îÄ Step 2: Process nodes ‚îÄ‚îÄ</span>
        <span class="n">start_node</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;node_x&quot;</span><span class="p">:[],</span><span class="s2">&quot;node_y&quot;</span><span class="p">:[],</span><span class="s2">&quot;node_texts&quot;</span><span class="p">:[]}</span>
        <span class="n">final_node</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;node_x&quot;</span><span class="p">:[],</span><span class="s2">&quot;node_y&quot;</span><span class="p">:[],</span><span class="s2">&quot;node_texts&quot;</span><span class="p">:[]}</span>
        <span class="n">middle_node</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;node_x&quot;</span><span class="p">:[],</span><span class="s2">&quot;node_y&quot;</span><span class="p">:[],</span><span class="s2">&quot;node_texts&quot;</span><span class="p">:[]}</span>
        <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;ntype&quot;</span><span class="p">]</span> <span class="o">==</span><span class="s2">&quot;raw_data&quot;</span><span class="p">:</span>
                <span class="n">start_node</span><span class="p">[</span><span class="s2">&quot;node_x&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="n">start_node</span><span class="p">[</span><span class="s2">&quot;node_y&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
                <span class="n">start_node</span><span class="p">[</span><span class="s2">&quot;node_texts&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;ntype&quot;</span><span class="p">]</span> <span class="o">==</span><span class="s2">&quot;Output&quot;</span><span class="p">:</span>
                <span class="n">final_node</span><span class="p">[</span><span class="s2">&quot;node_x&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="n">final_node</span><span class="p">[</span><span class="s2">&quot;node_y&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
                <span class="n">final_node</span><span class="p">[</span><span class="s2">&quot;node_texts&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;ntype&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;derivatives&quot;</span><span class="p">:</span>
                <span class="n">middle_node</span><span class="p">[</span><span class="s2">&quot;node_x&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="n">middle_node</span><span class="p">[</span><span class="s2">&quot;node_y&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
                <span class="n">middle_node</span><span class="p">[</span><span class="s2">&quot;node_texts&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

            
        <span class="c1"># ‚îÄ‚îÄ Step 3: Build Plotly figure ‚îÄ‚îÄ</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">go</span><span class="o">.</span><span class="n">Figure</span><span class="p">()</span>

        <span class="c1"># Draw edges</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">add_trace</span><span class="p">(</span><span class="n">go</span><span class="o">.</span><span class="n">Scatter</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">edge_x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">edge_y</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="s2">&quot;lines&quot;</span><span class="p">,</span><span class="n">line</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="s2">&quot;gray&quot;</span><span class="p">),</span><span class="n">hoverinfo</span><span class="o">=</span><span class="s2">&quot;none&quot;</span><span class="p">,</span><span class="n">showlegend</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>

        <span class="c1"># Draw edge labels at midpoints</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">add_trace</span><span class="p">(</span><span class="n">go</span><span class="o">.</span><span class="n">Scatter</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">label_x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">label_y</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="s2">&quot;text&quot;</span><span class="p">,</span><span class="n">text</span><span class="o">=</span><span class="n">edge_text</span><span class="p">,</span><span class="n">textposition</span><span class="o">=</span><span class="s2">&quot;top center&quot;</span><span class="p">,</span>
                                 <span class="n">textfont</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">12</span><span class="p">),</span><span class="n">hovertext</span><span class="o">=</span><span class="n">edge_labels</span><span class="p">,</span><span class="n">hoverinfo</span><span class="o">=</span><span class="s2">&quot;text&quot;</span><span class="p">,</span><span class="n">showlegend</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
        <span class="c1"># Draw input nodes</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">add_trace</span><span class="p">(</span><span class="n">go</span><span class="o">.</span><span class="n">Scatter</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">start_node</span><span class="p">[</span><span class="s2">&quot;node_x&quot;</span><span class="p">],</span> <span class="n">y</span><span class="o">=</span><span class="n">start_node</span><span class="p">[</span><span class="s2">&quot;node_y&quot;</span><span class="p">],</span><span class="n">mode</span><span class="o">=</span><span class="s2">&quot;markers+text&quot;</span><span class="p">,</span>
            <span class="n">marker</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="s2">&quot;lightgreen&quot;</span><span class="p">,</span><span class="n">symbol</span><span class="o">=</span><span class="s2">&quot;circle&quot;</span><span class="p">,</span><span class="n">line</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">width</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">)),</span>
            <span class="n">text</span><span class="o">=</span><span class="n">start_node</span><span class="p">[</span><span class="s2">&quot;node_texts&quot;</span><span class="p">],</span><span class="n">textposition</span><span class="o">=</span><span class="s2">&quot;bottom center&quot;</span><span class="p">,</span><span class="n">hoverinfo</span><span class="o">=</span><span class="s2">&quot;text&quot;</span><span class="p">,</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;raw_data&quot;</span><span class="p">,</span><span class="n">showlegend</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
        <span class="c1"># Draw task nodes</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">add_trace</span><span class="p">(</span><span class="n">go</span><span class="o">.</span><span class="n">Scatter</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">middle_node</span><span class="p">[</span><span class="s2">&quot;node_x&quot;</span><span class="p">],</span> <span class="n">y</span><span class="o">=</span><span class="n">middle_node</span><span class="p">[</span><span class="s2">&quot;node_y&quot;</span><span class="p">],</span><span class="n">mode</span><span class="o">=</span><span class="s2">&quot;markers+text&quot;</span><span class="p">,</span>
            <span class="n">marker</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="s2">&quot;orange&quot;</span><span class="p">,</span><span class="n">symbol</span><span class="o">=</span><span class="s2">&quot;square&quot;</span><span class="p">,</span><span class="n">line</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">width</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">)),</span>
            <span class="n">text</span><span class="o">=</span><span class="n">middle_node</span><span class="p">[</span><span class="s2">&quot;node_texts&quot;</span><span class="p">],</span><span class="n">textposition</span><span class="o">=</span><span class="s2">&quot;bottom center&quot;</span><span class="p">,</span><span class="n">hoverinfo</span><span class="o">=</span><span class="s2">&quot;text&quot;</span><span class="p">,</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;derivatives&quot;</span><span class="p">,</span><span class="n">showlegend</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
        <span class="c1"># Draw output nodes</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">add_trace</span><span class="p">(</span><span class="n">go</span><span class="o">.</span><span class="n">Scatter</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">final_node</span><span class="p">[</span><span class="s2">&quot;node_x&quot;</span><span class="p">],</span> <span class="n">y</span><span class="o">=</span><span class="n">final_node</span><span class="p">[</span><span class="s2">&quot;node_y&quot;</span><span class="p">],</span><span class="n">mode</span><span class="o">=</span><span class="s2">&quot;markers+text&quot;</span><span class="p">,</span>
            <span class="n">marker</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="s2">&quot;royalblue&quot;</span><span class="p">,</span><span class="n">symbol</span><span class="o">=</span><span class="s2">&quot;star&quot;</span><span class="p">,</span><span class="n">line</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">width</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">)),</span>
            <span class="n">text</span><span class="o">=</span><span class="n">final_node</span><span class="p">[</span><span class="s2">&quot;node_texts&quot;</span><span class="p">],</span><span class="n">textposition</span><span class="o">=</span><span class="s2">&quot;bottom center&quot;</span><span class="p">,</span><span class="n">hoverinfo</span><span class="o">=</span><span class="s2">&quot;text&quot;</span><span class="p">,</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Final Dataset&quot;</span><span class="p">,</span><span class="n">showlegend</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>

        <span class="c1"># ‚îÄ‚îÄ Step 4: Layout and display ‚îÄ‚îÄ</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">update_layout</span><span class="p">(</span><span class="n">showlegend</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                          <span class="n">xaxis</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">showticklabels</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">showgrid</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">zeroline</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
            <span class="n">yaxis</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">showticklabels</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">showgrid</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">zeroline</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
            <span class="n">margin</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">l</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">20</span><span class="p">),</span><span class="n">width</span><span class="o">=</span><span class="mi">800</span><span class="p">,</span><span class="n">height</span><span class="o">=</span><span class="mi">120</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">exec_order</span><span class="p">)</span> <span class="o">+</span> <span class="mi">3</span><span class="p">),</span>
            <span class="n">annotations</span><span class="o">=</span><span class="n">annotations</span><span class="p">)</span>
    
    <span class="c1"># === Matplotlib static visualization ===</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Define node groups</span>
        <span class="n">start_nodes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">final_nodes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">middle_nodes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;ntype&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;raw_data&quot;</span><span class="p">:</span>
                <span class="n">start_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;ntype&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;Output&quot;</span><span class="p">:</span>
                <span class="n">final_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;ntype&quot;</span><span class="p">]</span> <span class="o">==</span><span class="s2">&quot;derivatives&quot;</span><span class="p">:</span>
                <span class="n">middle_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>

        <span class="c1"># Draw nodes by shape and color</span>
        <span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">nodelist</span><span class="o">=</span><span class="n">start_nodes</span><span class="p">,</span> <span class="n">node_shape</span><span class="o">=</span><span class="s2">&quot;o&quot;</span><span class="p">,</span> <span class="n">node_color</span><span class="o">=</span><span class="s2">&quot;lightgreen&quot;</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span><span class="n">node_size</span><span class="o">=</span><span class="mi">1500</span><span class="p">)</span>
        <span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">nodelist</span><span class="o">=</span><span class="n">final_nodes</span><span class="p">,</span> <span class="n">node_shape</span><span class="o">=</span><span class="s2">&quot;*&quot;</span><span class="p">,</span> <span class="n">node_color</span><span class="o">=</span><span class="s2">&quot;royalblue&quot;</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span><span class="n">node_size</span><span class="o">=</span><span class="mi">1500</span><span class="p">)</span>
        <span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">nodelist</span><span class="o">=</span><span class="n">middle_nodes</span><span class="p">,</span> <span class="n">node_shape</span><span class="o">=</span><span class="s2">&quot;s&quot;</span><span class="p">,</span> <span class="n">node_color</span><span class="o">=</span><span class="s2">&quot;orange&quot;</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span><span class="n">node_size</span><span class="o">=</span><span class="mi">1500</span><span class="p">)</span>

        <span class="c1"># Draw edges and labels</span>
        <span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_edges</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span><span class="n">arrowsize</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">node_size</span><span class="o">=</span><span class="mi">1500</span><span class="p">)</span>
        <span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_labels</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>

        <span class="c1"># Define legend elements only for circle-shaped (task) nodes</span>
        <span class="n">legend_elements</span> <span class="o">=</span> <span class="p">[</span><span class="n">Line2D</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;o&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;w&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;raw_data&quot;</span><span class="p">,</span><span class="n">markerfacecolor</span><span class="o">=</span><span class="s2">&quot;lightgreen&quot;</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">15</span><span class="p">),</span>
                           <span class="n">Line2D</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;s&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;w&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;derivatives&quot;</span><span class="p">,</span><span class="n">markerfacecolor</span><span class="o">=</span><span class="s2">&quot;orange&quot;</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">15</span><span class="p">),</span>
                           <span class="n">Line2D</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;*&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;w&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Final Dataset&quot;</span><span class="p">,</span><span class="n">markerfacecolor</span><span class="o">=</span><span class="s2">&quot;royalblue&quot;</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">15</span><span class="p">)]</span>
        <span class="c1"># Add the legend</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">handles</span><span class="o">=</span><span class="n">legend_elements</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="s2">&quot;upper right&quot;</span><span class="p">,</span> <span class="n">frameon</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">show</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">return_fig</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">fig</span></div>


<span class="c1"># ----------------- Pipeline graph related helpers ------------------</span>

<div class="viewcode-block" id="build_dependency_graph">
<a class="viewcode-back" href="../../../gencap.utils.html#gencap.utils.helpers.build_dependency_graph">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">build_dependency_graph</span><span class="p">(</span><span class="n">tasks</span><span class="p">,</span> <span class="n">io_mappings</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Build a Directed Acyclic Graph (DAG) representing task dependencies in a pipeline.</span>

<span class="sd">    This function generates a NetworkX graph to represent task execution order, inputs,</span>
<span class="sd">    and outputs. It includes:</span>
<span class="sd">    </span>
<span class="sd">    * A synthetic &quot;Cohort&quot; input node.</span>
<span class="sd">    * Task nodes annotated with input/output field labels.</span>
<span class="sd">    * Directed edges based on I/O mappings.</span>

<span class="sd">    Args:</span>
<span class="sd">        tasks (dict): </span>
<span class="sd">            Mapping of task alias IDs to task objects. Each task must define:</span>
<span class="sd">            - ``mandatory_input_fields``</span>
<span class="sd">            - ``optional_input_fields``</span>
<span class="sd">            - ``mandatory_output_fields``</span>
<span class="sd">            - ``optional_output_fields``</span>
<span class="sd">        io_mappings (dict): </span>
<span class="sd">            Mapping of task alias IDs to I/O field connections.</span>
<span class="sd">            Each value is a dict where keys are destination fields and values </span>
<span class="sd">            are lists of the form ``[source_task_alias, source_field]``.</span>

<span class="sd">    Returns:</span>
<span class="sd">        networkx.DiGraph:</span>
<span class="sd">            A DAG where:</span>
<span class="sd">            - Nodes represent tasks or the synthetic Cohort input.</span>
<span class="sd">            - Edges represent data dependencies between tasks.</span>
<span class="sd">    </span>
<span class="sd">    Notes:</span>
<span class="sd">        * Ensures DAG acyclicity.</span>
<span class="sd">        * Includes metadata for visualization (labels, highlighting).</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; G = build_dependency_graph(tasks, io_mappings)</span>
<span class="sd">        &gt;&gt;&gt; print(G.nodes())</span>
<span class="sd">        [(&#39;Cohort&#39;,), (&#39;Task1&#39;,), (&#39;Task2&#39;,)]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Step 1: Initialize an empty directed graph</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">()</span>

    <span class="c1"># Step 2: Add synthetic &quot;Cohort&quot; node as the pipeline&#39;s input sourcee</span>
    <span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">((</span><span class="s2">&quot;Cohort&quot;</span><span class="p">,),</span> <span class="n">ntype</span><span class="o">=</span><span class="s2">&quot;input&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">highlight</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="c1"># Step 3: Add task nodes with labels displaying task metadata and I/O fields</span>
    <span class="k">for</span> <span class="n">task_id</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tasks</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">in_list</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">mandatory_input_fields</span> <span class="o">+</span> <span class="n">t</span><span class="o">.</span><span class="n">optional_input_fields</span><span class="p">)</span>
        <span class="n">out_list</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">mandatory_output_fields</span> <span class="o">+</span> <span class="n">t</span><span class="o">.</span><span class="n">optional_output_fields</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="s2">&quot;task_dataset_id&quot;</span><span class="p">):</span>
            <span class="n">label</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">task_id</span><span class="si">}</span><span class="s2">&lt;br&gt;&lt;b&gt;Task Dataset ID&lt;/b&gt;: </span><span class="si">{</span><span class="n">t</span><span class="o">.</span><span class="n">task_dataset_id</span><span class="si">}</span><span class="s2">&lt;br&gt;&lt;b&gt;Unique ID&lt;/b&gt;: </span><span class="si">{</span><span class="n">t</span><span class="o">.</span><span class="n">unique_id</span><span class="si">}</span><span class="s2">&lt;br&gt;&lt;b&gt;IN&lt;/b&gt;: </span><span class="si">{</span><span class="n">in_list</span><span class="si">}</span><span class="s2">&lt;br&gt;&lt;b&gt;OUT&lt;/b&gt;: </span><span class="si">{</span><span class="n">out_list</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">label</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">task_id</span><span class="si">}</span><span class="s2">&lt;br&gt;&lt;b&gt;Unique ID&lt;/b&gt;: </span><span class="si">{</span><span class="n">t</span><span class="o">.</span><span class="n">unique_id</span><span class="si">}</span><span class="s2">&lt;br&gt;&lt;b&gt;IN&lt;/b&gt;: </span><span class="si">{</span><span class="n">in_list</span><span class="si">}</span><span class="s2">&lt;br&gt;&lt;b&gt;OUT&lt;/b&gt;: </span><span class="si">{</span><span class="n">out_list</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">task_id</span><span class="p">,</span> <span class="n">ntype</span><span class="o">=</span><span class="s2">&quot;task&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">,</span><span class="n">highlight</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="c1"># Step 4: Add edges based on I/O mappings</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">task_id</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tasks</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
        <span class="n">io_map</span> <span class="o">=</span> <span class="n">io_mappings</span><span class="p">[</span><span class="n">task_id</span><span class="p">]</span>
        <span class="n">tgt</span> <span class="o">=</span> <span class="n">task_id</span>

        <span class="c1"># First task always connected from &quot;Cohort&quot;</span>
        <span class="k">if</span> <span class="n">i</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">((</span><span class="s2">&quot;Cohort&quot;</span><span class="p">,),</span> <span class="n">tgt</span><span class="p">,</span> <span class="n">src_field</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dst_field</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;input dict&quot;</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="c1"># For subsequent tasks, link edges based on their source task/field</span>
        <span class="k">for</span> <span class="n">dst_field</span><span class="p">,</span> <span class="n">spec</span> <span class="ow">in</span> <span class="n">io_map</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">spec</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">src</span> <span class="o">=</span> <span class="n">spec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">src_field</span> <span class="o">=</span> <span class="n">spec</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="c1"># Add edge to graph</span>
                <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">tgt</span><span class="p">,</span> <span class="n">src_field</span><span class="o">=</span><span class="n">src_field</span><span class="p">,</span> <span class="n">dst_field</span><span class="o">=</span><span class="n">dst_field</span><span class="p">,</span>
                           <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">src_field</span><span class="si">}</span><span class="s2"> ‚Üí </span><span class="si">{</span><span class="n">dst_field</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;All values of IO_dict should be list.&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">G</span></div>


<div class="viewcode-block" id="get_sorted_execution_order">
<a class="viewcode-back" href="../../../gencap.utils.html#gencap.utils.helpers.get_sorted_execution_order">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_sorted_execution_order</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Retrieve topologically sorted execution order from a DAG.</span>

<span class="sd">    Args:</span>
<span class="sd">        G (networkx.DiGraph): </span>
<span class="sd">            Directed acyclic graph representing task dependencies.</span>

<span class="sd">    Returns:</span>
<span class="sd">        list:</span>
<span class="sd">            Ordered list of nodes (tasks) excluding raw_data nodes.</span>

<span class="sd">    Notes:</span>
<span class="sd">        * Filters out nodes tagged with ``ntype=&#39;raw_data&#39;``.</span>
<span class="sd">        * Useful for determining pipeline execution order.</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; exec_order = get_sorted_execution_order(G)</span>
<span class="sd">        &gt;&gt;&gt; print(exec_order)</span>
<span class="sd">        [(&#39;Task1&#39;,), (&#39;Task2&#39;,), (&#39;Task3&#39;,)]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Filter out raw_data nodes</span>
    <span class="n">filtered_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">if</span> <span class="n">attr</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;ntype&quot;</span><span class="p">)</span> <span class="o">!=</span> <span class="s2">&quot;raw_data&quot;</span><span class="p">]</span>

    <span class="c1"># Generate subgraph without raw_data nodes</span>
    <span class="n">subgraph</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">filtered_nodes</span><span class="p">)</span>

    <span class="c1"># Perform topological sorting</span>
    <span class="n">sorted_nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">topological_sort</span><span class="p">(</span><span class="n">subgraph</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">sorted_nodes</span></div>


<div class="viewcode-block" id="visualize_pipeline">
<a class="viewcode-back" href="../../../gencap.utils.html#gencap.utils.helpers.visualize_pipeline">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">visualize_pipeline</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">pipeline_info</span><span class="o">=</span><span class="p">{},</span> <span class="n">return_fig</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">nicePlots</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                       <span class="n">highlight_node</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Visualize a pipeline DAG with tasks, inputs, and outputs.</span>

<span class="sd">    This function renders the pipeline graph using Plotly (interactive) or Matplotlib (static).</span>
<span class="sd">    Nodes are color-coded by type, and edges display their field mapping relationships.</span>

<span class="sd">    Features:</span>
<span class="sd">        * Adds synthetic output nodes for terminal tasks.</span>
<span class="sd">        * Distinguishes node types with shapes and colors:</span>
<span class="sd">          - Input (Cohort): light gray square</span>
<span class="sd">          - Tasks: light blue circles</span>
<span class="sd">          - Outputs: light green squares</span>
<span class="sd">          - Highlighted task: pink circle</span>
<span class="sd">        * Displays input/output field mappings as edge labels.</span>

<span class="sd">    Args:</span>
<span class="sd">        graph (networkx.DiGraph): </span>
<span class="sd">            Directed acyclic graph built using :func:`build_dependency_graph`.</span>
<span class="sd">        pipeline_info (dict, optional): </span>
<span class="sd">            Pipeline metadata including cohort arguments and runtime inputs.</span>
<span class="sd">        return_fig (bool, optional): </span>
<span class="sd">            If True, returns the figure object instead of showing it.</span>
<span class="sd">        nicePlots (bool, optional): </span>
<span class="sd">            If True, uses Plotly for interactive visualization; otherwise uses Matplotlib.</span>
<span class="sd">        highlight_node (tuple or str, optional): </span>
<span class="sd">            Task node to visually highlight in the graph.</span>
<span class="sd">        show (bool, optional): </span>
<span class="sd">            Whether to display the figure immediately. Defaults to False.</span>
<span class="sd">        logger (logging.Logger, optional): </span>
<span class="sd">            Logger instance for logging workflow visualization steps.</span>

<span class="sd">    Returns:</span>
<span class="sd">        plotly.graph_objects.Figure or matplotlib.figure.Figure:</span>
<span class="sd">            Visualization figure object if ``return_fig=True``.</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; G = build_dependency_graph(tasks, io_mappings)</span>
<span class="sd">        &gt;&gt;&gt; visualize_pipeline(G, pipeline_info=pipeline_info, nicePlots=True, highlight_node=(&#39;Task2&#39;,))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">logger</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Drawing workflow graph...&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Drawing workflow graph...&quot;</span><span class="p">)</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
    <span class="n">exec_order</span> <span class="o">=</span> <span class="p">[</span><span class="n">task</span> <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="n">nx</span><span class="o">.</span><span class="n">topological_sort</span><span class="p">(</span><span class="n">G</span><span class="p">)</span> <span class="k">if</span> <span class="n">task</span> <span class="o">!=</span><span class="p">(</span><span class="s2">&quot;Cohort&quot;</span><span class="p">,)]</span>
    
    <span class="c1"># Step 1: Add virtual output nodes for sink tasks</span>
    <span class="n">sinks</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span> <span class="k">if</span> <span class="n">G</span><span class="o">.</span><span class="n">out_degree</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sinks</span><span class="p">):</span>
        <span class="n">node_label</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="s2">&quot;label&quot;</span><span class="p">]</span>
        <span class="n">out_fields</span> <span class="o">=</span> <span class="n">node_label</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;OUT&lt;/b&gt;: &quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sinks</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">out_node</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Output-</span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out_node</span> <span class="o">=</span> <span class="s2">&quot;Output&quot;</span>
        <span class="n">out_label</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">out_node</span><span class="si">}</span><span class="s2">&lt;br&gt;&lt;b&gt;OUT&lt;/b&gt;: </span><span class="si">{</span><span class="n">out_fields</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">out_node</span><span class="p">,</span> <span class="n">ntype</span><span class="o">=</span><span class="s2">&quot;output&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">out_label</span><span class="p">,</span><span class="n">highlight</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">out_node</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>

    <span class="c1"># Step 2: Update Cohort node with runtime arguments</span>
    <span class="k">if</span> <span class="s2">&quot;cohort_arg&quot;</span> <span class="ow">in</span> <span class="n">pipeline_info</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="ow">and</span> <span class="n">pipeline_info</span><span class="p">[</span><span class="s2">&quot;cohort_arg&quot;</span><span class="p">][</span><span class="s2">&quot;cohortDatasetList&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">in_list</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pipeline_info</span><span class="p">[</span><span class="s2">&quot;cohort_arg&quot;</span><span class="p">][</span><span class="s2">&quot;cohortColumns&quot;</span><span class="p">])</span>
        <span class="n">label</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Cohort&lt;br&gt;&lt;b&gt;IN&lt;/b&gt;: </span><span class="si">{</span><span class="n">in_list</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[(</span><span class="s2">&quot;Cohort&quot;</span><span class="p">,)][</span><span class="s2">&quot;label&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">label</span>
    <span class="c1"># Update Cohort-to-first-task edge labels</span>
    <span class="k">if</span> <span class="s2">&quot;pipe_run_arg&quot;</span> <span class="ow">in</span> <span class="n">pipeline_info</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">tgt</span><span class="o">=</span> <span class="n">pipeline_info</span><span class="p">[</span><span class="s2">&quot;exec_order&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">label</span><span class="o">=</span><span class="s2">&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pipeline_info</span><span class="p">[</span><span class="s2">&quot;pipe_run_arg&quot;</span><span class="p">][</span><span class="s2">&quot;input_dict&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
            <span class="n">label</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2"> ‚Üí </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">i</span><span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">pipeline_info</span><span class="p">[</span><span class="s2">&quot;pipe_run_arg&quot;</span><span class="p">][</span><span class="s2">&quot;input_dict&quot;</span><span class="p">])</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">label</span><span class="o">+=</span><span class="s2">&quot;&lt;br&gt;&quot;</span>
        <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">[(</span><span class="s2">&quot;Cohort&quot;</span><span class="p">,),</span> <span class="n">tgt</span><span class="p">][</span><span class="s2">&quot;label&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">label</span>
    <span class="c1"># Highlight specific node if requested</span>
    <span class="k">if</span> <span class="n">highlight_node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">highlight_node</span><span class="p">][</span><span class="s2">&quot;highlight&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="c1"># Step 3: Layout graph using Graphviz</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="n">graphviz_layout</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">prog</span><span class="o">=</span><span class="s2">&quot;dot&quot;</span><span class="p">)</span>
    
    <span class="c1"># Step 4: Render graph (Plotly or Matplotlib)</span>
    <span class="k">if</span> <span class="n">nicePlots</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="c1"># --- Plotly Interactive Visualization ---</span>
        <span class="c1"># Prepare edge traces, labels, and arrows</span>
        <span class="n">edge_x</span><span class="p">,</span> <span class="n">edge_y</span><span class="p">,</span><span class="n">label_x</span><span class="p">,</span> <span class="n">label_y</span><span class="p">,</span> <span class="n">edge_labels</span><span class="p">,</span><span class="n">annotations</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],[]</span>
        <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">edata</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="n">x0</span><span class="p">,</span> <span class="n">y0</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="n">u</span><span class="p">]</span>
            <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>

            <span class="c1"># Collect edge line coordinates</span>
            <span class="n">edge_x</span> <span class="o">+=</span> <span class="p">[</span><span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
            <span class="n">edge_y</span> <span class="o">+=</span> <span class="p">[</span><span class="n">y0</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>

            <span class="c1"># Compute midpoint for edge label</span>
            <span class="n">mx</span><span class="p">,</span> <span class="n">my</span> <span class="o">=</span> <span class="p">(</span><span class="n">x0</span> <span class="o">+</span> <span class="n">x1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="n">y0</span> <span class="o">+</span> <span class="n">y1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="n">label_x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mx</span><span class="p">)</span>
            <span class="n">label_y</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">my</span><span class="p">)</span>
            <span class="n">edge_labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edata</span><span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">])</span>

            <span class="c1"># Create arrow annotation from source to target node</span>
            <span class="n">annotations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">x0</span><span class="p">,</span> <span class="n">ay</span><span class="o">=</span><span class="n">y0</span><span class="p">,</span><span class="n">x</span><span class="o">=</span><span class="n">x1</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">y1</span><span class="p">,</span><span class="n">axref</span><span class="o">=</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">ayref</span><span class="o">=</span><span class="s2">&quot;y&quot;</span><span class="p">,</span><span class="n">xref</span><span class="o">=</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">yref</span><span class="o">=</span><span class="s2">&quot;y&quot;</span><span class="p">,</span>
                <span class="n">showarrow</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">arrowhead</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span><span class="n">arrowsize</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">arrowwidth</span><span class="o">=</span><span class="mf">1.5</span><span class="p">,</span><span class="n">arrowcolor</span><span class="o">=</span><span class="s2">&quot;gray&quot;</span><span class="p">))</span>

        <span class="c1"># Separate nodes by type (task, input, output, highlight)</span>
        <span class="n">highlight_node</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;node_x&quot;</span><span class="p">:[],</span><span class="s2">&quot;node_y&quot;</span><span class="p">:[],</span><span class="s2">&quot;node_texts&quot;</span><span class="p">:[],</span><span class="s2">&quot;node_labels&quot;</span><span class="p">:[]}</span>
        <span class="n">task_node</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;node_x&quot;</span><span class="p">:[],</span><span class="s2">&quot;node_y&quot;</span><span class="p">:[],</span><span class="s2">&quot;node_texts&quot;</span><span class="p">:[],</span><span class="s2">&quot;node_labels&quot;</span><span class="p">:[]}</span>
        <span class="n">input_node</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;node_x&quot;</span><span class="p">:[],</span><span class="s2">&quot;node_y&quot;</span><span class="p">:[],</span><span class="s2">&quot;node_texts&quot;</span><span class="p">:[],</span><span class="s2">&quot;node_labels&quot;</span><span class="p">:[]}</span>
        <span class="n">output_node</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;node_x&quot;</span><span class="p">:[],</span><span class="s2">&quot;node_y&quot;</span><span class="p">:[],</span><span class="s2">&quot;node_texts&quot;</span><span class="p">:[],</span><span class="s2">&quot;node_labels&quot;</span><span class="p">:[]}</span>
        <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;ntype&quot;</span><span class="p">]</span> <span class="o">==</span><span class="s2">&quot;task&quot;</span> <span class="ow">and</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;highlight&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">highlight_node</span><span class="p">[</span><span class="s2">&quot;node_x&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="n">highlight_node</span><span class="p">[</span><span class="s2">&quot;node_y&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
                <span class="n">highlight_node</span><span class="p">[</span><span class="s2">&quot;node_texts&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
                <span class="n">highlight_node</span><span class="p">[</span><span class="s2">&quot;node_labels&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;ntype&quot;</span><span class="p">]</span> <span class="o">==</span><span class="s2">&quot;task&quot;</span><span class="p">:</span>
                <span class="n">task_node</span><span class="p">[</span><span class="s2">&quot;node_x&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="n">task_node</span><span class="p">[</span><span class="s2">&quot;node_y&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
                <span class="n">task_node</span><span class="p">[</span><span class="s2">&quot;node_texts&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
                <span class="n">task_node</span><span class="p">[</span><span class="s2">&quot;node_labels&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;ntype&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;input&quot;</span><span class="p">:</span>
                <span class="n">input_node</span><span class="p">[</span><span class="s2">&quot;node_x&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="n">input_node</span><span class="p">[</span><span class="s2">&quot;node_y&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
                <span class="n">input_node</span><span class="p">[</span><span class="s2">&quot;node_texts&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
                <span class="n">input_node</span><span class="p">[</span><span class="s2">&quot;node_labels&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">])</span>
            <span class="k">elif</span>  <span class="n">data</span><span class="p">[</span><span class="s2">&quot;ntype&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;output&quot;</span><span class="p">:</span>
                <span class="n">output_node</span><span class="p">[</span><span class="s2">&quot;node_x&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="n">output_node</span><span class="p">[</span><span class="s2">&quot;node_y&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
                <span class="n">output_node</span><span class="p">[</span><span class="s2">&quot;node_texts&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
                <span class="n">output_node</span><span class="p">[</span><span class="s2">&quot;node_labels&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">pass</span>

        <span class="c1"># Build Plotly figure (nodes + edges)</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">go</span><span class="o">.</span><span class="n">Figure</span><span class="p">()</span>

        <span class="c1"># Draw edges</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">add_trace</span><span class="p">(</span><span class="n">go</span><span class="o">.</span><span class="n">Scatter</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">edge_x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">edge_y</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="s2">&quot;lines&quot;</span><span class="p">,</span><span class="n">line</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="s2">&quot;gray&quot;</span><span class="p">),</span><span class="n">hoverinfo</span><span class="o">=</span><span class="s2">&quot;none&quot;</span><span class="p">,</span><span class="n">showlegend</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>

        <span class="c1"># Draw edge labels at midpoints</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">add_trace</span><span class="p">(</span><span class="n">go</span><span class="o">.</span><span class="n">Scatter</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">label_x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">label_y</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="s2">&quot;text&quot;</span><span class="p">,</span><span class="n">text</span><span class="o">=</span><span class="n">edge_labels</span><span class="p">,</span><span class="n">textposition</span><span class="o">=</span><span class="s2">&quot;top center&quot;</span><span class="p">,</span>
                                 <span class="n">textfont</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">12</span><span class="p">),</span><span class="n">hovertext</span><span class="o">=</span><span class="n">edge_labels</span><span class="p">,</span><span class="n">hoverinfo</span><span class="o">=</span><span class="s2">&quot;text&quot;</span><span class="p">,</span><span class="n">showlegend</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>

        <span class="c1"># Draw input nodes</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">add_trace</span><span class="p">(</span><span class="n">go</span><span class="o">.</span><span class="n">Scatter</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">input_node</span><span class="p">[</span><span class="s2">&quot;node_x&quot;</span><span class="p">],</span> <span class="n">y</span><span class="o">=</span><span class="n">input_node</span><span class="p">[</span><span class="s2">&quot;node_y&quot;</span><span class="p">],</span><span class="n">mode</span><span class="o">=</span><span class="s2">&quot;markers+text&quot;</span><span class="p">,</span>
            <span class="n">marker</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="s2">&quot;lightgrey&quot;</span><span class="p">,</span><span class="n">symbol</span><span class="o">=</span><span class="s2">&quot;square&quot;</span><span class="p">,</span><span class="n">line</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">width</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">)),</span>
            <span class="n">text</span><span class="o">=</span><span class="n">input_node</span><span class="p">[</span><span class="s2">&quot;node_texts&quot;</span><span class="p">],</span><span class="n">textposition</span><span class="o">=</span><span class="s2">&quot;bottom center&quot;</span><span class="p">,</span><span class="n">hovertext</span><span class="o">=</span><span class="n">input_node</span><span class="p">[</span><span class="s2">&quot;node_labels&quot;</span><span class="p">],</span><span class="n">hoverinfo</span><span class="o">=</span><span class="s2">&quot;text&quot;</span><span class="p">,</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Cohort&quot;</span><span class="p">,</span><span class="n">showlegend</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
        <span class="c1"># Draw output nodes</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">add_trace</span><span class="p">(</span><span class="n">go</span><span class="o">.</span><span class="n">Scatter</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">output_node</span><span class="p">[</span><span class="s2">&quot;node_x&quot;</span><span class="p">],</span> <span class="n">y</span><span class="o">=</span><span class="n">output_node</span><span class="p">[</span><span class="s2">&quot;node_y&quot;</span><span class="p">],</span><span class="n">mode</span><span class="o">=</span><span class="s2">&quot;markers+text&quot;</span><span class="p">,</span>
            <span class="n">marker</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="s2">&quot;lightgreen&quot;</span><span class="p">,</span><span class="n">symbol</span><span class="o">=</span><span class="s2">&quot;square&quot;</span><span class="p">,</span><span class="n">line</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">width</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">)),</span>
            <span class="n">text</span><span class="o">=</span><span class="n">output_node</span><span class="p">[</span><span class="s2">&quot;node_texts&quot;</span><span class="p">],</span><span class="n">textposition</span><span class="o">=</span><span class="s2">&quot;bottom center&quot;</span><span class="p">,</span><span class="n">hovertext</span><span class="o">=</span><span class="n">output_node</span><span class="p">[</span><span class="s2">&quot;node_labels&quot;</span><span class="p">],</span><span class="n">hoverinfo</span><span class="o">=</span><span class="s2">&quot;text&quot;</span><span class="p">,</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Output&quot;</span><span class="p">,</span><span class="n">showlegend</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
        <span class="c1"># Draw task nodes</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">add_trace</span><span class="p">(</span><span class="n">go</span><span class="o">.</span><span class="n">Scatter</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">task_node</span><span class="p">[</span><span class="s2">&quot;node_x&quot;</span><span class="p">],</span> <span class="n">y</span><span class="o">=</span><span class="n">task_node</span><span class="p">[</span><span class="s2">&quot;node_y&quot;</span><span class="p">],</span><span class="n">mode</span><span class="o">=</span><span class="s2">&quot;markers+text&quot;</span><span class="p">,</span>
            <span class="n">marker</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="s2">&quot;lightblue&quot;</span><span class="p">,</span><span class="n">symbol</span><span class="o">=</span><span class="s2">&quot;circle&quot;</span><span class="p">,</span><span class="n">line</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">width</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">)),</span>
            <span class="n">text</span><span class="o">=</span><span class="n">task_node</span><span class="p">[</span><span class="s2">&quot;node_texts&quot;</span><span class="p">],</span><span class="n">textposition</span><span class="o">=</span><span class="s2">&quot;bottom center&quot;</span><span class="p">,</span><span class="n">hovertext</span><span class="o">=</span><span class="n">task_node</span><span class="p">[</span><span class="s2">&quot;node_labels&quot;</span><span class="p">],</span><span class="n">hoverinfo</span><span class="o">=</span><span class="s2">&quot;text&quot;</span><span class="p">,</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Task&quot;</span><span class="p">,</span><span class="n">showlegend</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
        <span class="c1"># Draw highlight nodes</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">add_trace</span><span class="p">(</span><span class="n">go</span><span class="o">.</span><span class="n">Scatter</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">highlight_node</span><span class="p">[</span><span class="s2">&quot;node_x&quot;</span><span class="p">],</span> <span class="n">y</span><span class="o">=</span><span class="n">highlight_node</span><span class="p">[</span><span class="s2">&quot;node_y&quot;</span><span class="p">],</span><span class="n">mode</span><span class="o">=</span><span class="s2">&quot;markers+text&quot;</span><span class="p">,</span>
            <span class="n">marker</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="s2">&quot;pink&quot;</span><span class="p">,</span><span class="n">symbol</span><span class="o">=</span><span class="s2">&quot;circle&quot;</span><span class="p">,</span><span class="n">line</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">width</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">)),</span>
            <span class="n">text</span><span class="o">=</span><span class="n">highlight_node</span><span class="p">[</span><span class="s2">&quot;node_texts&quot;</span><span class="p">],</span><span class="n">textposition</span><span class="o">=</span><span class="s2">&quot;bottom center&quot;</span><span class="p">,</span><span class="n">hovertext</span><span class="o">=</span><span class="n">highlight_node</span><span class="p">[</span><span class="s2">&quot;node_labels&quot;</span><span class="p">],</span><span class="n">hoverinfo</span><span class="o">=</span><span class="s2">&quot;text&quot;</span><span class="p">,</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Current Task&quot;</span><span class="p">,</span><span class="n">showlegend</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>

        <span class="c1"># Layout and display ‚îÄ‚îÄ</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">update_layout</span><span class="p">(</span><span class="n">showlegend</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                          <span class="n">xaxis</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">showticklabels</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">showgrid</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">zeroline</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
            <span class="n">yaxis</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">showticklabels</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">showgrid</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">zeroline</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
            <span class="n">margin</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">l</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">20</span><span class="p">),</span><span class="n">width</span><span class="o">=</span><span class="mi">800</span><span class="p">,</span><span class="n">height</span><span class="o">=</span><span class="mi">120</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">exec_order</span><span class="p">)</span> <span class="o">+</span> <span class="mi">3</span><span class="p">),</span>
            <span class="n">annotations</span><span class="o">=</span><span class="n">annotations</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># --- Matplotlib Static Visualization ---</span>
        <span class="c1"># Define node groups</span>
        <span class="n">cohort_nodes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">output_nodes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">circle_nodes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">highlight_circle_node</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;ntype&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;input&quot;</span><span class="p">:</span>
                <span class="n">cohort_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;ntype&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;output&quot;</span><span class="p">:</span>
                <span class="n">output_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;ntype&quot;</span><span class="p">]</span> <span class="o">==</span><span class="s2">&quot;task&quot;</span> <span class="ow">and</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;highlight&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">highlight_circle_node</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="k">else</span> <span class="p">:</span>
                <span class="n">circle_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>

        <span class="c1"># Draw nodes by shape and color</span>
        <span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">nodelist</span><span class="o">=</span><span class="n">circle_nodes</span><span class="p">,</span> <span class="n">node_shape</span><span class="o">=</span><span class="s2">&quot;o&quot;</span><span class="p">,</span> <span class="n">node_color</span><span class="o">=</span><span class="s2">&quot;lightblue&quot;</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span><span class="n">node_size</span><span class="o">=</span><span class="mi">1500</span><span class="p">)</span>
        <span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">nodelist</span><span class="o">=</span><span class="n">cohort_nodes</span><span class="p">,</span> <span class="n">node_shape</span><span class="o">=</span><span class="s2">&quot;s&quot;</span><span class="p">,</span> <span class="n">node_color</span><span class="o">=</span><span class="s2">&quot;lightgray&quot;</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span><span class="n">node_size</span><span class="o">=</span><span class="mi">1500</span><span class="p">)</span>
        <span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">nodelist</span><span class="o">=</span><span class="n">output_nodes</span><span class="p">,</span> <span class="n">node_shape</span><span class="o">=</span><span class="s2">&quot;s&quot;</span><span class="p">,</span> <span class="n">node_color</span><span class="o">=</span><span class="s2">&quot;lightgreen&quot;</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span><span class="n">node_size</span><span class="o">=</span><span class="mi">1500</span><span class="p">)</span>
        <span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">nodelist</span><span class="o">=</span><span class="n">highlight_circle_node</span><span class="p">,</span> <span class="n">node_shape</span><span class="o">=</span><span class="s2">&quot;o&quot;</span><span class="p">,</span> <span class="n">node_color</span><span class="o">=</span><span class="s2">&quot;pink&quot;</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span><span class="n">node_size</span><span class="o">=</span><span class="mi">1500</span><span class="p">)</span>

        <span class="c1"># Draw edges and labels</span>
        <span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_edges</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span><span class="n">arrowsize</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">node_size</span><span class="o">=</span><span class="mi">1500</span><span class="p">)</span>
        <span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_labels</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>

        <span class="c1"># Define legend elements only for circle-shaped (task) nodes</span>
        <span class="n">legend_elements</span> <span class="o">=</span> <span class="p">[</span><span class="n">Line2D</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;s&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;w&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Cohort&quot;</span><span class="p">,</span><span class="n">markerfacecolor</span><span class="o">=</span><span class="s2">&quot;lightgray&quot;</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">15</span><span class="p">),</span>
                           <span class="n">Line2D</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;s&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;w&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Output&quot;</span><span class="p">,</span><span class="n">markerfacecolor</span><span class="o">=</span><span class="s2">&quot;lightgreen&quot;</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">15</span><span class="p">),</span>
                           <span class="n">Line2D</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;o&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;w&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Task&quot;</span><span class="p">,</span><span class="n">markerfacecolor</span><span class="o">=</span><span class="s2">&quot;lightblue&quot;</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">15</span><span class="p">),</span>
                           <span class="n">Line2D</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;o&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;w&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Current Task&quot;</span><span class="p">,</span><span class="n">markerfacecolor</span><span class="o">=</span><span class="s2">&quot;pink&quot;</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">15</span><span class="p">)]</span>
        <span class="c1"># Add the legend</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">handles</span><span class="o">=</span><span class="n">legend_elements</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="s2">&quot;upper right&quot;</span><span class="p">,</span> <span class="n">frameon</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">show</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">return_fig</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">fig</span></div>


<span class="c1"># -------------------------------------------------------------------------</span>
<span class="c1"># core/cohort.py helpers</span>
<span class="c1"># -------------------------------------------------------------------------</span>

<div class="viewcode-block" id="validate_dict_or_list_of_dict">
<a class="viewcode-back" href="../../../gencap.utils.html#gencap.utils.helpers.validate_dict_or_list_of_dict">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">validate_dict_or_list_of_dict</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">dataframes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">check_keys</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Validate an argument that can be either a dictionary or a list of dictionaries.</span>

<span class="sd">    This function ensures that the input object is of valid type (dict or list of dicts), </span>
<span class="sd">    optionally checks its length against the provided dataframes, and validates that </span>
<span class="sd">    dictionary keys exist in the dataframe columns if requested.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    obj : dict or list[dict]</span>
<span class="sd">        The object to validate. Can be a single dictionary or a list of dictionaries.</span>
<span class="sd">    name : str</span>
<span class="sd">        Name of the argument (used for informative error messages).</span>
<span class="sd">    dataframes : dict[str, pd.DataFrame], optional</span>
<span class="sd">        Mapping of dataframe names to dataframe objects. </span>
<span class="sd">        If provided, its length must match the length of ``obj`` when ``obj`` is a list.</span>
<span class="sd">    check_keys : bool, optional</span>
<span class="sd">        If True, validates that each key in the dictionaries exists in the corresponding</span>
<span class="sd">        dataframe&#39;s columns (via ``df.reset_index().columns``).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    bool</span>
<span class="sd">        Returns ``True`` if validation passes.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    TypeError</span>
<span class="sd">        If ``obj`` is not a dict or list of dicts, or if any element in the list is not a dict.</span>
<span class="sd">    ValueError</span>
<span class="sd">        If length of ``obj`` list does not match ``dataframes`` length,</span>
<span class="sd">        or if any dictionary key does not exist in the dataframe&#39;s columns (when ``check_keys=True``).</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; validate_dict_or_list_of_dict({&quot;Age&quot;: &quot;int&quot;}, &quot;fieldFormatDict&quot;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; validate_dict_or_list_of_dict([{&quot;Age&quot;: &quot;int&quot;}, {&quot;ID&quot;: &quot;str&quot;}], &quot;fieldFormatDict&quot;, dataframes={&quot;df1&quot;: df1, &quot;df2&quot;: df2})</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="p">(</span><span class="nb">dict</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> must be a dictionary or a list of dictionaries.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="c1"># Validate length match if dataframes provided</span>
        <span class="k">if</span> <span class="n">dataframes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dataframes</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The number of dataframes must match the number of </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> entries.&quot;</span>  <span class="c1"># noqa: E501</span>
            <span class="p">)</span>
        <span class="n">iterable</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">dataframes</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">obj</span><span class="p">)</span> <span class="k">if</span> <span class="n">dataframes</span> <span class="k">else</span> <span class="p">[(</span><span class="kc">None</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">obj</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">iterable</span> <span class="o">=</span> <span class="p">[((</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="n">obj</span><span class="p">)]</span>
    
    <span class="c1"># Validate each mapping</span>
    <span class="k">for</span> <span class="n">df_info</span><span class="p">,</span> <span class="n">mapping</span> <span class="ow">in</span> <span class="n">iterable</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Each item in </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> list must be a dictionary.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">check_keys</span> <span class="ow">and</span> <span class="n">df_info</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">df_name</span><span class="p">,</span> <span class="n">df</span> <span class="o">=</span> <span class="n">df_info</span>
            <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">mapping</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">field</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">df_name</span><span class="si">}</span><span class="s2"> - Assigned key &#39;</span><span class="si">{</span><span class="n">field</span><span class="si">}</span><span class="s2">&#39; in </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> doesn&#39;t exist in the DataFrame.&quot;</span>  <span class="c1"># noqa: E501</span>
                    <span class="p">)</span>

    <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="validate_values_are_dict">
<a class="viewcode-back" href="../../../gencap.utils.html#gencap.utils.helpers.validate_values_are_dict">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">validate_values_are_dict</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Validate that all values in a dictionary are themselves dictionaries.</span>

<span class="sd">    This is typically used to validate nested mapping structures, e.g., </span>
<span class="sd">    value replacement dictionaries.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mapping : dict</span>
<span class="sd">        The dictionary to validate.</span>
<span class="sd">    name : str</span>
<span class="sd">        Name of the argument (used in error messages).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    bool</span>
<span class="sd">        Returns ``True`` if all values are dictionaries.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    TypeError</span>
<span class="sd">        If any value is not a dictionary.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; validate_values_are_dict({&quot;Gender&quot;: {&quot;M&quot;: &quot;Male&quot;, &quot;F&quot;: &quot;Female&quot;}}, &quot;replaceValueDict&quot;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; validate_values_are_dict({&quot;Gender&quot;: &quot;Male&quot;}, &quot;replaceValueDict&quot;)</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">    TypeError: In replaceValueDict, value for field &#39;Gender&#39; must be a dictionary for replacement mapping.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">field</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">mapping</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;In </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">, value for field &#39;</span><span class="si">{</span><span class="n">field</span><span class="si">}</span><span class="s2">&#39; must be a dictionary for replacement mapping.&quot;</span>  <span class="c1"># noqa: E501</span>
            <span class="p">)</span>
    <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="fix_mixed_column_types">
<a class="viewcode-back" href="../../../gencap.utils.html#gencap.utils.helpers.fix_mixed_column_types">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">fix_mixed_column_types</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Detect and fix mixed-type columns in a DataFrame.</span>

<span class="sd">    For any column with mixed data types, converts all non-null values to the most </span>
<span class="sd">    frequent (dominant) type. Null values are preserved.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    df : pandas.DataFrame</span>
<span class="sd">        Input DataFrame to check and fix.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pandas.DataFrame</span>
<span class="sd">        A new DataFrame where columns with mixed types have been converted to a uniform type.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    * Uses the most frequent data type in the column to resolve mixed types.</span>
<span class="sd">    * Null (NaN) values are preserved without conversion.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import pandas as pd</span>
<span class="sd">    &gt;&gt;&gt; df = pd.DataFrame({&quot;col&quot;: [1, &quot;2&quot;, 3.0, None]})</span>
<span class="sd">    &gt;&gt;&gt; fixed_df = fix_mixed_column_types(df)</span>
<span class="sd">    &gt;&gt;&gt; fixed_df[&quot;col&quot;].apply(type).unique()</span>
<span class="sd">    [&lt;class &#39;int&#39;&gt;]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="n">non_null_values</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span>
        <span class="n">unique_types</span> <span class="o">=</span> <span class="n">non_null_values</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="nb">type</span><span class="p">)</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_types</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Identify unique non-null types in the column</span>
            <span class="n">type_counts</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">non_null_values</span><span class="p">)</span>
            <span class="n">target_type</span> <span class="o">=</span> <span class="n">type_counts</span><span class="o">.</span><span class="n">most_common</span><span class="p">(</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># If multiple types exist, normalize to the most frequent type</span>
            <span class="n">converted</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">df</span><span class="p">[</span><span class="n">col</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                    <span class="n">converted</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">converted</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">target_type</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
                    
            <span class="c1"># Convert values to the target type while preserving NaNs</span>
            <span class="n">df</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">converted</span>

    <span class="k">return</span> <span class="n">df</span></div>


<span class="c1"># -------------------------------------------------------------------------</span>
<span class="c1"># core/task.py helpers</span>
<span class="c1"># -------------------------------------------------------------------------</span>

<div class="viewcode-block" id="calculate_total_size">
<a class="viewcode-back" href="../../../gencap.utils.html#gencap.utils.helpers.calculate_total_size">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">calculate_total_size</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">file_location_fields</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the total size of files and directories referenced in a DataFrame.</span>

<span class="sd">    This function sums the sizes of files and directories listed in the specified </span>
<span class="sd">    file location fields of a dataset and returns the result in megabytes (MB).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    df : pandas.DataFrame</span>
<span class="sd">        DataFrame containing file path references.</span>
<span class="sd">    file_location_fields : list[str]</span>
<span class="sd">        List of column names in the DataFrame that contain file or directory paths.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float</span>
<span class="sd">        Total size of all files and directories (in MB), rounded to two decimal places.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    * File sizes are calculated using ``os.path.getsize``.</span>
<span class="sd">    * Directory sizes are calculated recursively by summing all contained files.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; size_mb = calculate_total_size(df, [&quot;Image Path&quot;, &quot;Mask Path&quot;])</span>
<span class="sd">    &gt;&gt;&gt; print(size_mb)</span>
<span class="sd">    125.73</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_directory_size</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Recursively calculate the total size of a directory.&quot;&quot;&quot;</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">pathlib</span><span class="w"> </span><span class="kn">import</span> <span class="n">Path</span>
        <span class="n">total_size</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">Path</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="o">.</span><span class="n">rglob</span><span class="p">(</span><span class="s2">&quot;*&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">file</span><span class="o">.</span><span class="n">is_file</span><span class="p">():</span>
                <span class="n">total_size</span> <span class="o">+=</span> <span class="n">file</span><span class="o">.</span><span class="n">stat</span><span class="p">()</span><span class="o">.</span><span class="n">st_size</span>
        <span class="k">return</span> <span class="n">total_size</span>
    <span class="n">file_paths</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">file_location_fields</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="n">file_paths</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="k">for</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="n">file_paths</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">sublist</span><span class="p">]</span>
    <span class="n">total_file_size</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">getsize</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">file_paths</span> <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
    <span class="n">total_dir_size</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">get_directory_size</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">file_paths</span> <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
    <span class="n">total_size</span> <span class="o">=</span> <span class="n">total_file_size</span> <span class="o">+</span> <span class="n">total_dir_size</span>
    <span class="c1"># Convert to MB</span>
    <span class="n">mb_size</span> <span class="o">=</span> <span class="n">total_size</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1024</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">round</span><span class="p">(</span><span class="n">mb_size</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span></div>


<div class="viewcode-block" id="count_total_files">
<a class="viewcode-back" href="../../../gencap.utils.html#gencap.utils.helpers.count_total_files">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">count_total_files</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">file_location_fields</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Count the total number of files referenced in a DataFrame.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    df : pandas.DataFrame</span>
<span class="sd">        DataFrame containing file path references.</span>
<span class="sd">    file_location_fields : list[str]</span>
<span class="sd">        List of column names in the DataFrame that contain file paths.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    int</span>
<span class="sd">        Total count of valid (non-&quot;None&quot;) file paths.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; count = count_total_files(df, [&quot;Image Path&quot;, &quot;Mask Path&quot;])</span>
<span class="sd">    &gt;&gt;&gt; print(count)</span>
<span class="sd">    342</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Flatten all file paths and exclude &quot;None&quot; placeholder values</span>
    <span class="n">file_paths</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">file_location_fields</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="n">file_paths</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="k">for</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="n">file_paths</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">sublist</span><span class="p">]</span>
    <span class="n">file_paths</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">file_paths</span> <span class="k">if</span> <span class="n">item</span> <span class="o">!=</span> <span class="s2">&quot;None&quot;</span><span class="p">]</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">file_paths</span><span class="p">)</span></div>


<div class="viewcode-block" id="remove_used_intermediate_data">
<a class="viewcode-back" href="../../../gencap.utils.html#gencap.utils.helpers.remove_used_intermediate_data">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">remove_used_intermediate_data</span><span class="p">(</span><span class="n">logger</span><span class="p">,</span> <span class="n">pipeline_dict</span><span class="p">,</span> <span class="n">task_info_dict</span><span class="p">,</span> <span class="n">output_dir</span><span class="p">,</span> <span class="n">current_task_id</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Remove intermediate task outputs no longer required in a pipeline.</span>

<span class="sd">    This function deletes intermediate files or directories produced by </span>
<span class="sd">    previous tasks in a pipeline if all their dependent downstream tasks </span>
<span class="sd">    have been completed. Certain files (e.g., QC or traceability reports) </span>
<span class="sd">    are excluded from deletion.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    logger : logging.Logger</span>
<span class="sd">        Logger instance for warnings or info messages.</span>
<span class="sd">    pipeline_dict : dict</span>
<span class="sd">        Dictionary containing pipeline metadata, including graph structure, </span>
<span class="sd">        task execution order, and task output directories.</span>
<span class="sd">    task_info_dict : dict</span>
<span class="sd">        Metadata for the current task (including ``prev_task`` dependencies).</span>
<span class="sd">    output_dir : str</span>
<span class="sd">        Root output directory containing task results.</span>
<span class="sd">    current_task_id : tuple</span>
<span class="sd">        Alias ID of the current task in the pipeline.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    * Files ``information.html`` and ``quality_control.html`` are preserved.</span>
<span class="sd">    * Only deletes intermediate task outputs if **all downstream tasks** </span>
<span class="sd">      dependent on that output have been executed.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; remove_used_intermediate_data(logger, pipeline_dict, task_info_dict, &quot;/outputs&quot;, (&quot;Task2&quot;,))</span>
<span class="sd">    [INFO] Intermediate files for Task1 have been cleaned up.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">shutil</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">pathlib</span><span class="w"> </span><span class="kn">import</span> <span class="n">Path</span>
    
    <span class="c1"># Files to exclude from deletion (traceability and QC reports)</span>
    <span class="n">EXCLUDE_FILES</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;information.html&quot;</span><span class="p">,</span> <span class="s2">&quot;quality_control.html&quot;</span><span class="p">}</span>

    <span class="c1"># Retrieve previous tasks for the current task</span>
    <span class="n">prev_tasks</span> <span class="o">=</span> <span class="n">task_info_dict</span><span class="p">[</span><span class="s2">&quot;prev_task&quot;</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">prev_t</span> <span class="ow">in</span> <span class="n">prev_tasks</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">prev_t</span> <span class="o">!=</span> <span class="p">(</span><span class="s2">&quot;Cohort&quot;</span><span class="p">,):</span>
            <span class="c1"># Identify tasks dependent on this previous task</span>
            <span class="n">next_tasks</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">pipeline_dict</span><span class="p">[</span><span class="s2">&quot;graph&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">successors</span><span class="p">(</span><span class="n">prev_t</span><span class="p">))</span>

            <span class="c1"># Get list of tasks completed up to (and including) current task</span>
            <span class="n">done_tasks</span> <span class="o">=</span> <span class="n">pipeline_dict</span><span class="p">[</span><span class="s2">&quot;exec_order&quot;</span><span class="p">][:</span><span class="n">pipeline_dict</span><span class="p">[</span><span class="s2">&quot;exec_order&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">current_task_id</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

            <span class="c1"># If all downstream tasks are completed, clean up intermediate data</span>
            <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">next_tasks</span><span class="p">)</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">done_tasks</span><span class="p">)):</span>
                <span class="c1"># Construct the output directory path for the previous task</span>
                <span class="n">prev_t_dataset_id</span><span class="o">=</span> <span class="n">pipeline_dict</span><span class="p">[</span><span class="s2">&quot;task_dataset_ids&quot;</span><span class="p">][</span><span class="n">prev_t</span><span class="p">]</span>
                <span class="n">output_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span> <span class="n">prev_t_dataset_id</span><span class="p">))</span>

                <span class="c1"># If the directory doesn&#39;t exist, skip it</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">output_path</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
                    <span class="k">continue</span>

                <span class="c1"># Iterate over files/directories in the task&#39;s output folder</span>
                <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">output_path</span><span class="o">.</span><span class="n">iterdir</span><span class="p">():</span>
                    <span class="c1"># Skip if directory doesn&#39;t exist</span>
                    <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">EXCLUDE_FILES</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="c1"># Delete directory or file</span>
                        <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">is_dir</span><span class="p">():</span>
                            <span class="n">shutil</span><span class="o">.</span><span class="n">rmtree</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>  <span class="c1"># Remove directories</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">f</span><span class="o">.</span><span class="n">unlink</span><span class="p">()</span> <span class="c1"># Remove individual files</span>
                    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                        <span class="c1"># Print warning if a deletion fails</span>
                        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[Warning] Failed to delete </span><span class="si">{</span><span class="n">f</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>


<span class="c1"># -------------------------------------------------------------------------</span>
<span class="c1"># core/pipeline.py helpers</span>
<span class="c1"># -------------------------------------------------------------------------</span>

<div class="viewcode-block" id="ensure_unique_instances">
<a class="viewcode-back" href="../../../gencap.utils.html#gencap.utils.helpers.ensure_unique_instances">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">ensure_unique_instances</span><span class="p">(</span><span class="n">tasks_io</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Ensure that each Task object instance is unique within the pipeline.</span>

<span class="sd">    If the same Task object is reused multiple times in the pipeline definition </span>
<span class="sd">    (i.e., the same Python object reference), it creates a deep copy to prevent </span>
<span class="sd">    shared state between different pipeline steps.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    tasks_io : list[tuple]</span>
<span class="sd">        A list of tuples, where each tuple is of the form ``(Task, io_mapping)``:</span>
<span class="sd">        * ``Task``: Task object instance.</span>
<span class="sd">        * ``io_mapping``: I/O mapping dictionary for that task.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list[tuple]</span>
<span class="sd">        A new list of ``(Task, io_mapping)`` pairs with duplicate Task objects </span>
<span class="sd">        deep-copied.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; tasks_io = [(task_a, {}), (task_a, {})]</span>
<span class="sd">    &gt;&gt;&gt; unique_tasks = ensure_unique_instances(tasks_io)</span>
<span class="sd">    &gt;&gt;&gt; unique_tasks[0][0] is unique_tasks[1][0]</span>
<span class="sd">    False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">seen</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">output</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">task</span><span class="p">,</span> <span class="n">io_map</span> <span class="ow">in</span> <span class="n">tasks_io</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">id</span><span class="p">(</span><span class="n">task</span><span class="p">)</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">:</span>
            <span class="n">task</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>  <span class="c1"># Ensure unique instance</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">seen</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">task</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">task</span><span class="p">,</span> <span class="n">io_map</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">output</span></div>



<div class="viewcode-block" id="assign_alias_ids">
<a class="viewcode-back" href="../../../gencap.utils.html#gencap.utils.helpers.assign_alias_ids">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">assign_alias_ids</span><span class="p">(</span><span class="n">tasks_list</span><span class="p">,</span> <span class="n">io_mappings_list</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Assign unique alias IDs to tasks and convert them into dictionaries.</span>

<span class="sd">    Alias IDs are tuples of the form ``(unique_id, instance_number)`` where </span>
<span class="sd">    ``instance_number`` increments for multiple instances of the same task.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    tasks_list : list[Task]</span>
<span class="sd">        List of Task objects.</span>
<span class="sd">    io_mappings_list : list[dict]</span>
<span class="sd">        List of I/O mapping dictionaries corresponding to each task.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tuple</span>
<span class="sd">        * **tasks_dict (dict):** Mapping of alias_id -&gt; Task object.</span>
<span class="sd">        * **io_mappings_dict (dict):** Mapping of alias_id -&gt; I/O mapping dict.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; tasks_dict, io_mappings_dict = assign_alias_ids([task1, task2], [io1, io2])</span>
<span class="sd">    &gt;&gt;&gt; print(tasks_dict.keys())</span>
<span class="sd">    [(task1_id, 1), (task2_id, 1)]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">tasks</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">tasks_list</span><span class="p">)</span>
    <span class="n">io_mappings</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">io_mappings_list</span><span class="p">)</span>

    <span class="n">tasks_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">io_mappings_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">counter</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">task</span><span class="p">,</span> <span class="n">io_dict</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">tasks</span><span class="p">,</span><span class="n">io_mappings</span><span class="p">):</span>
        <span class="n">unique_id</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">unique_id</span>
        <span class="n">counter</span><span class="p">[</span><span class="n">unique_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">counter</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">unique_id</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">alias_id</span> <span class="o">=</span> <span class="p">(</span><span class="n">unique_id</span><span class="p">,</span><span class="nb">int</span><span class="p">(</span><span class="n">counter</span><span class="p">[</span><span class="n">unique_id</span><span class="p">]))</span>
        <span class="n">tasks_dict</span><span class="p">[</span><span class="n">alias_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">task</span>
        <span class="n">io_mappings_dict</span><span class="p">[</span><span class="n">alias_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">io_dict</span>

    <span class="k">return</span> <span class="n">tasks_dict</span><span class="p">,</span> <span class="n">io_mappings_dict</span></div>


<div class="viewcode-block" id="convert_all_tuples_to_strings">
<a class="viewcode-back" href="../../../gencap.utils.html#gencap.utils.helpers.convert_all_tuples_to_strings">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">convert_all_tuples_to_strings</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Recursively convert all tuple keys and values in nested structures to strings.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    obj : dict, list, tuple, or any</span>
<span class="sd">        The object to recursively process.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict, list, str, or any</span>
<span class="sd">        Object with tuples converted to strings, preserving other types.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; convert_all_tuples_to_strings({(&quot;Task&quot;, 1): {&quot;field&quot;: (&quot;Task&quot;, 2)}})</span>
<span class="sd">    {&quot;(&#39;Task&#39;, 1)&quot;: {&quot;field&quot;: &quot;(&#39;Task&#39;, 2)&quot;}}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">convert_all_tuples_to_strings</span><span class="p">(</span><span class="n">k</span><span class="p">):</span> <span class="n">convert_all_tuples_to_strings</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">obj</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">convert_all_tuples_to_strings</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">obj</span><span class="p">]</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">obj</span></div>



<div class="viewcode-block" id="generate_empty_output_df">
<a class="viewcode-back" href="../../../gencap.utils.html#gencap.utils.helpers.generate_empty_output_df">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">generate_empty_output_df</span><span class="p">(</span><span class="n">Pipeline</span><span class="p">,</span> <span class="n">target_task</span><span class="p">,</span> <span class="n">input_dict</span><span class="o">=</span><span class="p">{},</span> <span class="n">pathname_policy_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate an empty DataFrame structured like the output of a target task.</span>

<span class="sd">    This is useful for pipeline validation, allowing checks on expected indexing </span>
<span class="sd">    fields and column structure without running actual tasks.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Pipeline : Pipeline</span>
<span class="sd">        Pipeline object containing task definitions, graph, and cohort data.</span>
<span class="sd">    target_task : tuple</span>
<span class="sd">        Alias ID of the target task (e.g., ``(&#39;TaskID&#39;, 1)``).</span>
<span class="sd">    input_dict : dict, optional</span>
<span class="sd">        Input mapping from pipeline input fields to task fields.</span>
<span class="sd">    pathname_policy_dict : dict, optional</span>
<span class="sd">        Pathname policy dict, used to include supplementary fields.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pandas.DataFrame</span>
<span class="sd">        An empty DataFrame matching the expected structure of the target task&#39;s output.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    * The returned DataFrame includes:</span>
<span class="sd">        - Properly configured multi-index based on task indexing fields.</span>
<span class="sd">        - Mandatory, optional, and supplementary columns.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; df = generate_empty_output_df(pipeline, (&quot;MyTask&quot;, 1))</span>
<span class="sd">    &gt;&gt;&gt; print(df.columns)</span>
<span class="sd">    Index([&#39;mandatory_field1&#39;, &#39;optional_field1&#39;, ...])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Use cohort index structure as base (most conservative default)</span>
    <span class="n">orig_df</span> <span class="o">=</span> <span class="n">Pipeline</span><span class="o">.</span><span class="n">cohort_df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">output_dfs</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="n">task_sequence</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">ancestors</span><span class="p">(</span><span class="n">Pipeline</span><span class="o">.</span><span class="n">graph</span><span class="p">,</span> <span class="n">target_task</span><span class="p">)))</span>
    <span class="n">task_sequence</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">target_task</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">task_name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">task_sequence</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">task_name</span> <span class="o">==</span> <span class="p">(</span><span class="s2">&quot;Cohort&quot;</span><span class="p">,):</span>
            <span class="n">current_df</span> <span class="o">=</span> <span class="n">orig_df</span>
            <span class="n">inverted_input_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">input_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
            <span class="n">output_dfs</span><span class="p">[</span><span class="n">task_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">current_df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">inverted_input_dict</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">prev_task_name</span> <span class="o">=</span> <span class="n">task_sequence</span><span class="p">[</span><span class="n">task_sequence</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">task_name</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">current_df</span> <span class="o">=</span> <span class="n">output_dfs</span><span class="p">[</span><span class="n">prev_task_name</span><span class="p">]</span>

            <span class="n">task</span> <span class="o">=</span> <span class="n">Pipeline</span><span class="o">.</span><span class="n">tasks</span><span class="p">[</span><span class="n">task_name</span><span class="p">]</span>
            <span class="n">io_dict</span> <span class="o">=</span> <span class="n">Pipeline</span><span class="o">.</span><span class="n">io_mappings</span><span class="p">[</span><span class="n">task_name</span><span class="p">]</span>
            
            <span class="c1"># Rename index fields based on I/O mappings</span>
            <span class="k">for</span> <span class="n">input_field</span><span class="p">,</span> <span class="n">refer_list</span> <span class="ow">in</span> <span class="n">io_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">refer_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">prev_task_name</span> <span class="ow">and</span> <span class="n">refer_list</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">current_df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
                    <span class="n">current_df</span><span class="o">.</span><span class="n">rename_axis</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="p">{</span><span class="n">refer_list</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span><span class="n">input_field</span><span class="p">})</span>
            
            <span class="c1"># Build indexing and column fields</span>
            <span class="n">indexing_fields</span> <span class="o">=</span> <span class="nb">list</span><span class="p">((</span><span class="nb">set</span><span class="p">(</span><span class="n">current_df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">names</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">additional_input_indexing_fields</span><span class="p">))</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">additional_output_indexing_fields</span><span class="p">)))</span>
            <span class="n">column_fields</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">mandatory_output_fields</span><span class="p">)</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">optional_output_fields</span><span class="p">)))</span>
            
            <span class="c1"># Add supplementary fields from pathname policy</span>
            <span class="k">if</span> <span class="n">pathname_policy_dict</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">keyword_fields</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">pathname_policy_dict</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">field</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">keyword_fields</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">field</span> <span class="o">==</span> <span class="s2">&quot;output indexing fields&quot;</span><span class="p">:</span>
                        <span class="n">keyword_fields</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                        <span class="n">keyword_fields</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">field</span><span class="p">:</span>
                            <span class="n">keyword_fields</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                <span class="n">supplementary_fields</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">keyword_fields</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">indexing_fields</span><span class="o">+</span><span class="n">column_fields</span><span class="p">))</span>
                <span class="n">column_fields</span> <span class="o">=</span> <span class="p">[</span><span class="o">*</span><span class="n">column_fields</span><span class="p">,</span> <span class="o">*</span><span class="n">supplementary_fields</span><span class="p">]</span>
            <span class="n">output_dfs</span><span class="p">[</span><span class="n">task_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">column_fields</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_tuples</span><span class="p">([],</span> <span class="n">names</span><span class="o">=</span><span class="n">indexing_fields</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">output_dfs</span><span class="p">[</span><span class="n">task_sequence</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span></div>


<div class="viewcode-block" id="get_name_mapper">
<a class="viewcode-back" href="../../../gencap.utils.html#gencap.utils.helpers.get_name_mapper">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_name_mapper</span><span class="p">(</span><span class="n">tasks</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate a mapping from task keys to their alias IDs.</span>

<span class="sd">    This function maps each task key in a task dictionary to its corresponding </span>
<span class="sd">    alias ID. For Task objects, their `alias_id` attribute is used directly; </span>
<span class="sd">    for tuples/lists, it generates an alias by counting occurrences.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    tasks : dict</span>
<span class="sd">        Dictionary mapping task keys to Task objects or task identifiers.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict</span>
<span class="sd">        Mapping of original task keys to alias IDs as tuples (task_id, instance_number).</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; tasks = {(&quot;TaskA&quot;, 1): taskA, (&quot;TaskB&quot;, 1): taskB}</span>
<span class="sd">    &gt;&gt;&gt; get_name_mapper(tasks)</span>
<span class="sd">    {(&quot;TaskA&quot;, 1): (&quot;TaskA&quot;, 1), (&quot;TaskB&quot;, 1): (&quot;TaskB&quot;, 1)}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">defaultdict</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">gencap.core.task</span><span class="w"> </span><span class="kn">import</span> <span class="n">Task</span>
    <span class="n">all_keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">tasks</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

    <span class="c1"># initialize counter of task_unique_id</span>
    <span class="n">task_counts</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

    <span class="c1"># initialize mapping dict</span>
    <span class="n">name_mapper</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">all_keys</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tasks</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tasks</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">task_unique_id</span> <span class="o">=</span> <span class="n">tasks</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">task_counts</span><span class="p">[</span><span class="n">task_unique_id</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">alias_number</span> <span class="o">=</span> <span class="n">task_counts</span><span class="p">[</span><span class="n">task_unique_id</span><span class="p">]</span>
            <span class="n">name_mapper</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">task_unique_id</span><span class="p">,</span> <span class="n">alias_number</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tasks</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">Task</span><span class="p">):</span>
            <span class="n">name_mapper</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">tasks</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">alias_id</span>

    <span class="k">return</span> <span class="n">name_mapper</span></div>


<div class="viewcode-block" id="rename_io_mapping">
<a class="viewcode-back" href="../../../gencap.utils.html#gencap.utils.helpers.rename_io_mapping">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">rename_io_mapping</span><span class="p">(</span><span class="n">io_mappings</span><span class="p">,</span> <span class="n">name_mapper</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Rename task keys and source references in I/O mappings using alias IDs.</span>

<span class="sd">    This function updates task keys in the I/O mappings and normalizes</span>
<span class="sd">    references to source tasks based on a provided `name_mapper`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    io_mappings : dict</span>
<span class="sd">        Original I/O mappings. Keys are task identifiers (tuples or lists) and</span>
<span class="sd">        values are dictionaries of field mappings.</span>
<span class="sd">    name_mapper : dict</span>
<span class="sd">        Dictionary mapping old task identifiers (tuple, list, or string) to </span>
<span class="sd">        their normalized alias IDs.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict</span>
<span class="sd">        Updated I/O mappings with task keys and references renamed using the alias IDs.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    * Supports legacy JSON pipeline formats where keys or references may appear as lists.</span>
<span class="sd">    * Automatically handles nested task references inside field specifications.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; io_mappings = {</span>
<span class="sd">    ...     [&quot;TaskA&quot;]: {&quot;field1&quot;: [[&quot;TaskB&quot;], &quot;output_field&quot;]}</span>
<span class="sd">    ... }</span>
<span class="sd">    &gt;&gt;&gt; name_mapper = {(&quot;TaskA&quot;, 1): (&quot;TaskA&quot;, 1), (&quot;TaskB&quot;, 1): (&quot;TaskB&quot;, 1)}</span>
<span class="sd">    &gt;&gt;&gt; rename_io_mapping(io_mappings, name_mapper)</span>
<span class="sd">    {(&quot;TaskA&quot;, 1): {&quot;field1&quot;: [(&quot;TaskB&quot;, 1), &quot;output_field&quot;]}}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">updated_io_mappings</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">for</span> <span class="n">old_key</span><span class="p">,</span> <span class="n">mapping</span> <span class="ow">in</span> <span class="n">io_mappings</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="c1"># ``old_key`` may be a list when coming from old JSON files</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">old_key</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">old_key</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">old_key</span><span class="p">)</span>

        <span class="n">new_key</span> <span class="o">=</span> <span class="n">name_mapper</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">old_key</span><span class="p">,</span> <span class="n">old_key</span><span class="p">)</span>
        <span class="n">new_mapping</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">dst_field</span><span class="p">,</span> <span class="n">spec</span> <span class="ow">in</span> <span class="n">mapping</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">spec</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="c1"># Normalize source references</span>
                <span class="n">src</span> <span class="o">=</span> <span class="n">spec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                    <span class="n">src</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">src</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">src</span> <span class="ow">in</span> <span class="n">name_mapper</span><span class="p">:</span>
                    <span class="n">new_mapping</span><span class="p">[</span><span class="n">dst_field</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">name_mapper</span><span class="p">[</span><span class="n">src</span><span class="p">],</span> <span class="n">spec</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># keep the original reference</span>
                    <span class="n">new_mapping</span><span class="p">[</span><span class="n">dst_field</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">src</span><span class="p">,</span> <span class="n">spec</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Leave unchanged for non-list mappings</span>
                <span class="n">new_mapping</span><span class="p">[</span><span class="n">dst_field</span><span class="p">]</span> <span class="o">=</span> <span class="n">spec</span>

        <span class="n">updated_io_mappings</span><span class="p">[</span><span class="n">new_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_mapping</span>

    <span class="k">return</span> <span class="n">updated_io_mappings</span></div>


<div class="viewcode-block" id="resolve_io_mapping">
<a class="viewcode-back" href="../../../gencap.utils.html#gencap.utils.helpers.resolve_io_mapping">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">resolve_io_mapping</span><span class="p">(</span><span class="n">tasks</span><span class="p">,</span> <span class="n">io_mappings</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Resolve ambiguous or shorthand task references in I/O mappings.</span>

<span class="sd">    This function updates I/O mappings to ensure that all references point to</span>
<span class="sd">    fully qualified alias IDs of tasks, resolving shorthand notations such as:</span>
<span class="sd">    * &quot;pipeline_input&quot; -&gt; Cohort alias.</span>
<span class="sd">    * Task unique_id (string) -&gt; most recent matching task alias.</span>
<span class="sd">    * Task index (int) -&gt; positional lookup.</span>
<span class="sd">    * Explicit alias tuple -&gt; validated reference.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    tasks : dict</span>
<span class="sd">        Mapping of alias IDs to Task objects.</span>
<span class="sd">    io_mappings : dict</span>
<span class="sd">        Mapping of alias IDs to their corresponding I/O mappings.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict</span>
<span class="sd">        Updated I/O mappings with resolved references.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If a reference cannot be resolved or is invalid.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; resolved = resolve_io_mapping(tasks, io_mappings)</span>
<span class="sd">    &gt;&gt;&gt; print(resolved[(&quot;TaskB&quot;, 1)])</span>
<span class="sd">    {&quot;input_field&quot;: [(&quot;TaskA&quot;, 1), &quot;output_field&quot;]}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">task_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">tasks</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="n">updated_io_mappings</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">task_id</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">task_list</span><span class="p">):</span>
        <span class="n">io_map</span> <span class="o">=</span> <span class="n">io_mappings</span><span class="p">[</span><span class="n">task_id</span><span class="p">]</span>
        <span class="c1"># First task: initialize empty mapping</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">updated_io_mappings</span><span class="p">[</span><span class="n">task_id</span><span class="p">]</span><span class="o">=</span><span class="p">{}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">updated_io_map</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">dst_field</span><span class="p">,</span> <span class="n">spec</span> <span class="ow">in</span> <span class="n">io_map</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="c1"># ‚îÄ‚îÄ Case 1: input from &quot;pipeline_input&quot; (i.e., Cohort)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">spec</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">spec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;pipeline_input&quot;</span><span class="p">:</span>
                        <span class="n">updated_io_map</span><span class="p">[</span><span class="n">dst_field</span><span class="p">]</span><span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;Cohort&quot;</span><span class="p">,),</span> <span class="n">spec</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

                <span class="c1"># ‚îÄ‚îÄ Case 2: input from a specific task&#39;s output: [&quot;TaskID&quot;, &quot;Field&quot;]</span>
                    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">spec</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">str</span><span class="p">):</span>
                        <span class="n">src_unique_id</span> <span class="o">=</span> <span class="n">spec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">cur_idx</span> <span class="o">=</span> <span class="n">task_list</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">task_id</span><span class="p">)</span>
                        <span class="c1"># Search backwards for the most recent task with matching unique_id</span>
                        <span class="n">src</span> <span class="o">=</span> <span class="kc">None</span>
                        <span class="k">for</span> <span class="n">search_task_id</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">task_list</span><span class="p">[:</span><span class="n">cur_idx</span><span class="p">]):</span>
                            <span class="k">if</span> <span class="n">tasks</span><span class="p">[</span><span class="n">search_task_id</span><span class="p">]</span><span class="o">.</span><span class="n">unique_id</span> <span class="o">==</span> <span class="n">src_unique_id</span><span class="p">:</span>
                                <span class="n">src</span> <span class="o">=</span> <span class="n">search_task_id</span>
                                <span class="n">updated_io_map</span><span class="p">[</span><span class="n">dst_field</span><span class="p">]</span><span class="o">=</span> <span class="p">[</span><span class="n">src</span><span class="p">,</span> <span class="n">spec</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
                                <span class="k">break</span>
                        <span class="k">if</span> <span class="n">src</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No previous task with unique_id &#39;</span><span class="si">{</span><span class="n">src_unique_id</span><span class="si">}</span><span class="s2">&#39; found before &#39;</span><span class="si">{</span><span class="n">tasks</span><span class="p">[</span><span class="n">task_id</span><span class="p">]</span><span class="o">.</span><span class="n">unique_id</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>

                <span class="c1"># ‚îÄ‚îÄ Case 3: input from a specific task&#39;s output: [2, &quot;Field&quot;]</span>
                    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">spec</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">int</span><span class="p">):</span>
                        <span class="n">src</span> <span class="o">=</span> <span class="n">task_list</span><span class="p">[</span><span class="n">spec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                        <span class="n">updated_io_map</span><span class="p">[</span><span class="n">dst_field</span><span class="p">]</span><span class="o">=</span> <span class="p">[</span><span class="n">src</span><span class="p">,</span> <span class="n">spec</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

                <span class="c1"># ‚îÄ‚îÄ Case 4: input from a specific task&#39;s output: [(&quot;TaskID&quot;,1), &quot;Field&quot;]</span>
                    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">spec</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">):</span>
                        <span class="n">cur_idx</span> <span class="o">=</span> <span class="n">task_list</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">task_id</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">spec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">task_list</span><span class="p">[:</span><span class="n">cur_idx</span><span class="p">]:</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No previous task with unique_id &#39;</span><span class="si">{</span><span class="n">spec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&#39; found before &#39;</span><span class="si">{</span><span class="n">tasks</span><span class="p">[</span><span class="n">task_id</span><span class="p">]</span><span class="o">.</span><span class="n">unique_id</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">updated_io_map</span><span class="p">[</span><span class="n">dst_field</span><span class="p">]</span><span class="o">=</span> <span class="n">spec</span>

                <span class="c1"># ‚îÄ‚îÄ Case 4: input from previous task (implicit)</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">spec</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="n">prev_idx</span> <span class="o">=</span> <span class="n">task_list</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">task_id</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
                    <span class="n">src</span> <span class="o">=</span> <span class="n">task_list</span><span class="p">[</span><span class="n">prev_idx</span><span class="p">]</span>
                    <span class="n">updated_io_map</span><span class="p">[</span><span class="n">dst_field</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">src</span><span class="p">,</span> <span class="n">spec</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Assigned list as a value of io_dict is not configurable.&quot;</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">dst_field</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">updated_io_map</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Assigned list as a value of io_dict is not configurable.&quot;</span><span class="p">)</span>
            <span class="n">updated_io_mappings</span><span class="p">[</span><span class="n">task_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">updated_io_map</span>

    <span class="k">return</span> <span class="n">updated_io_mappings</span></div>


<div class="viewcode-block" id="resolve_parameter_dict">
<a class="viewcode-back" href="../../../gencap.utils.html#gencap.utils.helpers.resolve_parameter_dict">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">resolve_parameter_dict</span><span class="p">(</span><span class="n">parameter_dict</span><span class="p">,</span> <span class="n">tasks</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Resolve task parameter dictionary into a task-alias-keyed format.</span>

<span class="sd">    This function ensures that task parameters are correctly mapped to their alias IDs.</span>
<span class="sd">    It supports:</span>
<span class="sd">    * Single-task pipelines where parameters may be provided as a flat dict.</span>
<span class="sd">    * Multi-task pipelines where parameters may be keyed by unique IDs, alias tuples,</span>
<span class="sd">      or both.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    parameter_dict : dict</span>
<span class="sd">        Dictionary of parameters. Keys can be:</span>
<span class="sd">        * Task unique IDs (str)</span>
<span class="sd">        * Alias tuples (task_id, instance_number)</span>
<span class="sd">    tasks : dict</span>
<span class="sd">        Dictionary of tasks keyed by alias IDs.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict</span>
<span class="sd">        Resolved parameter dictionary keyed by alias IDs.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If an invalid key is provided or does not correspond to any task in the pipeline.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; params = {&quot;MyTask&quot;: {&quot;param1&quot;: 10}}</span>
<span class="sd">    &gt;&gt;&gt; resolved = resolve_parameter_dict(params, tasks)</span>
<span class="sd">    &gt;&gt;&gt; print(resolved)</span>
<span class="sd">    {(&quot;MyTask&quot;, 1): {&quot;param1&quot;: 10}}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">resolved_parameter_dict</span><span class="o">=</span><span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="kc">None</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">tasks</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span>
    
    <span class="c1"># Multi-task pipelines</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tasks</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">parameter_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>  <span class="c1"># Unique ID string</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="n">alias_id</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">alias_id</span> <span class="ow">in</span> <span class="n">tasks</span><span class="o">.</span><span class="n">keys</span><span class="p">()]:</span>
                    <span class="k">for</span> <span class="n">alias_id</span> <span class="ow">in</span> <span class="n">resolved_parameter_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                        <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="n">alias_id</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                            <span class="n">resolved_parameter_dict</span><span class="p">[</span><span class="n">alias_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">parameter_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2"> of parameter_dict is not found in the configured tasks.&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>   <span class="c1"># Alias tuple</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">tasks</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">resolved_parameter_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">parameter_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2"> of parameter_dict is not found in the configured tasks.&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2"> of parameter_dict was given with unexpected type. parameter_dict should be two level of dictionary.&quot;</span><span class="p">)</span>
                
    <span class="c1"># Single-task pipelines</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">parameter_dict</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">parameter_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">resolved_parameter_dict</span><span class="o">=</span><span class="n">parameter_dict</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">resolved_parameter_dict</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">tasks</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">]]</span><span class="o">=</span><span class="n">parameter_dict</span>
    <span class="k">return</span> <span class="n">resolved_parameter_dict</span></div>



<span class="c1"># -------------------------------------------------------------------------</span>
<span class="c1"># tasks/generic.py helpers</span>
<span class="c1"># -------------------------------------------------------------------------</span>

<div class="viewcode-block" id="generate_unique_name_with_prefix">
<a class="viewcode-back" href="../../../gencap.utils.html#gencap.utils.helpers.generate_unique_name_with_prefix">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">generate_unique_name_with_prefix</span><span class="p">(</span><span class="n">databaseDir</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">prefix</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate a unique dataset name with a given prefix.</span>

<span class="sd">    This function ensures that the new dataset name does not conflict with existing </span>
<span class="sd">    datasets in the specified database directory. If a conflict is detected, it </span>
<span class="sd">    increments the version number using a `#` suffix.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    databaseDir : str</span>
<span class="sd">        Root directory of the dataset database.</span>
<span class="sd">    data : str</span>
<span class="sd">        Base dataset name.</span>
<span class="sd">    prefix : str</span>
<span class="sd">        Prefix string to prepend to the dataset name.</span>
<span class="sd">    logger : logging.Logger, optional</span>
<span class="sd">        Logger instance for warnings and messages.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    str</span>
<span class="sd">        A unique dataset name including the prefix.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    RuntimeError</span>
<span class="sd">        If the generated dataset name unexpectedly resolves to an existing path.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; generate_unique_name_with_prefix(&quot;/data/db&quot;, &quot;BrainMRI&quot;, &quot;Study&quot;)</span>
<span class="sd">    &#39;Study-#2-BrainMRI&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">path_list</span> <span class="o">=</span> <span class="n">find_dataset_path_with_prefix</span><span class="p">(</span><span class="n">datasetName</span><span class="o">=</span><span class="n">data</span><span class="p">,</span><span class="n">databaseDir</span><span class="o">=</span><span class="n">databaseDir</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="n">prefix</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">path_list</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># Generate candidate names: base and versioned</span>
        <span class="n">search_reproduced_name</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">data</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">#</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">data</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">path_list</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="n">reproduced_name_list</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">search_reproduced_name</span><span class="p">)</span>
        
        <span class="c1"># Remove existing names from the candidate list</span>
        <span class="k">for</span> <span class="n">search_name</span> <span class="ow">in</span> <span class="n">search_reproduced_name</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">find_path</span> <span class="o">=</span> <span class="n">find_dataset_path</span><span class="p">(</span><span class="n">datasetName</span><span class="o">=</span><span class="n">search_name</span><span class="p">,</span><span class="n">databaseDir</span><span class="o">=</span><span class="n">databaseDir</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">find_path</span><span class="p">:</span>
                    <span class="n">reproduced_name_list</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">search_name</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="k">pass</span>
            
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">reproduced_name_list</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># All candidates exist: increment version further</span>
            <span class="n">reproduced_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">#</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">path_list</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">data</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">if</span> <span class="n">logger</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Warning: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">path_list</span><span class="p">)</span><span class="si">}</span><span class="s2"> datasets have the same prefix; the reproduced name will be set as [</span><span class="si">{</span><span class="n">reproduced_name</span><span class="si">}</span><span class="s2">].&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Warning: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">path_list</span><span class="p">)</span><span class="si">}</span><span class="s2"> datasets have the same prefix; the reproduced name will be set as [</span><span class="si">{</span><span class="n">reproduced_name</span><span class="si">}</span><span class="s2">].&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">reproduced_name</span> <span class="o">=</span> <span class="n">reproduced_name_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">reproduced_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">data</span><span class="si">}</span><span class="s2">&quot;</span>
    
    <span class="c1"># Verify final name does not already exist</span>
    <span class="n">new_path</span> <span class="o">=</span> <span class="n">find_dataset_path</span><span class="p">(</span><span class="n">databaseDir</span><span class="p">,</span> <span class="n">reproduced_name</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">new_path</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">reproduced_name</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Something went wrong. Found path  </span><span class="si">{</span><span class="n">new_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>



<div class="viewcode-block" id="compare_datasets">
<a class="viewcode-back" href="../../../gencap.utils.html#gencap.utils.helpers.compare_datasets">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">compare_datasets</span><span class="p">(</span><span class="n">original_dir</span><span class="p">,</span> <span class="n">reproduced_dir</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compare an original dataset against a reproduced dataset for structural and file-level equivalence.</span>

<span class="sd">    This function performs:</span>
<span class="sd">      1. Comparison of indexing fields and columns.</span>
<span class="sd">      2. Metadata comparison (excluding file paths).</span>
<span class="sd">      3. Bitwise file comparison for files listed in `fileLocationFieldList`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    original_dir : str</span>
<span class="sd">        Path to the original dataset directory.</span>
<span class="sd">    reproduced_dir : str</span>
<span class="sd">        Path to the reproduced dataset directory.</span>
<span class="sd">    logger : logging.Logger, optional</span>
<span class="sd">        Logger instance for info/warning messages.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tuple</span>
<span class="sd">        * **valid_code (list[int])**: List of codes indicating issues (1=index mismatch, 2=column mismatch, etc.).</span>
<span class="sd">        * **result_df (pd.DataFrame)**: File comparison results.</span>
<span class="sd">        * **error_df (pd.DataFrame)**: File-level errors encountered.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    * Uses bitwise file comparison to ensure file content integrity.</span>
<span class="sd">    * Displays table-level differences using pandas `DataFrame.compare()` for debugging.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; codes, results, errors = compare_datasets(&quot;/path/orig&quot;, &quot;/path/reprod&quot;)</span>
<span class="sd">    &gt;&gt;&gt; print(codes)</span>
<span class="sd">    [1, 3]  # Index mismatch and table content differences detected.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">json</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">IPython.display</span><span class="w"> </span><span class="kn">import</span> <span class="n">display</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">compare_files_bitwise</span><span class="p">(</span><span class="n">path1</span><span class="p">,</span> <span class="n">path2</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Perform bitwise file comparison.&quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path1</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f1</span><span class="p">,</span> <span class="nb">open</span><span class="p">(</span><span class="n">path2</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f2</span><span class="p">:</span>
            <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">b1</span> <span class="o">=</span> <span class="n">f1</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">4096</span><span class="p">)</span>
                <span class="n">b2</span> <span class="o">=</span> <span class="n">f2</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">4096</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">b1</span> <span class="o">!=</span> <span class="n">b2</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">b1</span><span class="p">:</span>  <span class="c1"># End of file</span>
                    <span class="k">break</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="n">valid_code</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="c1"># Load datasets</span>
    <span class="n">df_orig</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_pickle</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">original_dir</span><span class="p">,</span><span class="s2">&quot;data_content.pkl&quot;</span><span class="p">))</span>
    <span class="n">df_reprod</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_pickle</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">reproduced_dir</span><span class="p">,</span><span class="s2">&quot;data_content.pkl&quot;</span><span class="p">))</span>

    <span class="n">df_orig</span><span class="o">=</span><span class="n">df_orig</span><span class="o">.</span><span class="n">sort_index</span><span class="p">()</span>
    <span class="n">df_reprod</span><span class="o">=</span><span class="n">df_reprod</span><span class="o">.</span><span class="n">sort_index</span><span class="p">()</span>
    
    <span class="c1"># 1. Compare indexing fields</span>
    <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">df_orig</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">names</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">(</span><span class="n">df_reprod</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">names</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">logger</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">reproduced_dir</span><span class="p">)</span><span class="si">}</span><span class="s2">] - Indexing fields mismatch. Compared original path:[</span><span class="si">{</span><span class="n">original_dir</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">reproduced_dir</span><span class="p">)</span><span class="si">}</span><span class="s2">] - Indexing fields mismatch. Compared original path:[</span><span class="si">{</span><span class="n">original_dir</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">)</span>
        <span class="n">valid_code</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># 2. Compare columns</span>
    <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">df_orig</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">(</span><span class="n">df_reprod</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">logger</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">reproduced_dir</span><span class="p">)</span><span class="si">}</span><span class="s2">] - column fields mismatch. Compared original path:[</span><span class="si">{</span><span class="n">original_dir</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">reproduced_dir</span><span class="p">)</span><span class="si">}</span><span class="s2">] - column fields mismatch. Compared original path:[</span><span class="si">{</span><span class="n">original_dir</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">)</span>
        <span class="n">valid_code</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

    <span class="c1"># 3. Compare metadata excluding file paths</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">original_dir</span><span class="p">,</span> <span class="s2">&quot;data_description.json&quot;</span><span class="p">),</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">data_desc</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="n">file_fields</span> <span class="o">=</span> <span class="n">data_desc</span><span class="p">[</span><span class="s2">&quot;fileLocationFieldList&quot;</span><span class="p">]</span>

    <span class="c1"># Compare tables directly (metadata) only except for the fileLocationField</span>
    <span class="k">if</span> <span class="n">df_orig</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">file_fields</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">df_reprod</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">file_fields</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">logger</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">reproduced_dir</span><span class="p">)</span><span class="si">}</span><span class="s2">] - DataFrames are identical at table level. Compared original path:[</span><span class="si">{</span><span class="n">original_dir</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">reproduced_dir</span><span class="p">)</span><span class="si">}</span><span class="s2">] - DataFrames are identical at table level. Compared original path:[</span><span class="si">{</span><span class="n">original_dir</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">logger</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">reproduced_dir</span><span class="p">)</span><span class="si">}</span><span class="s2">] - DataFrames are different in table contents! Compared original path:[</span><span class="si">{</span><span class="n">original_dir</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">reproduced_dir</span><span class="p">)</span><span class="si">}</span><span class="s2">] - DataFrames are different in table contents! Compared original path:[</span><span class="si">{</span><span class="n">original_dir</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">)</span>
        <span class="n">valid_code</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">display</span><span class="p">(</span><span class="n">df_orig</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">file_fields</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">compare</span><span class="p">(</span><span class="n">df_reprod</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">file_fields</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)))</span>

    <span class="c1"># 4. Bitwise file comparison</span>
    <span class="n">error_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
    <span class="n">result_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
    <span class="n">merged_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">df_orig</span><span class="p">,</span><span class="n">df_reprod</span><span class="p">,</span> <span class="n">right_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">left_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">suffixes</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;_orig&quot;</span><span class="p">,</span> <span class="s2">&quot;_re&quot;</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">merged_df</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">file_fields</span><span class="p">:</span>
            <span class="n">orig_file_path</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">field</span><span class="o">+</span><span class="s2">&quot;_orig&quot;</span><span class="p">]</span>
            <span class="n">reproduce_file_path</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">field</span><span class="o">+</span><span class="s2">&quot;_re&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">orig_file_path</span><span class="p">)</span> <span class="ow">and</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">reproduce_file_path</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">compare_files_bitwise</span><span class="p">(</span><span class="n">orig_file_path</span><span class="p">,</span> <span class="n">reproduce_file_path</span><span class="p">):</span>
                    <span class="n">result_row</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;Original File Path&quot;</span><span class="p">:</span> <span class="n">orig_file_path</span><span class="p">,</span><span class="s2">&quot;Reproduced File Path&quot;</span><span class="p">:</span> <span class="n">reproduce_file_path</span><span class="p">,</span><span class="s2">&quot;Field&quot;</span><span class="p">:</span> <span class="n">field</span><span class="p">,</span><span class="s2">&quot;Result&quot;</span><span class="p">:</span> <span class="s2">&quot;identical&quot;</span><span class="p">}</span>
                    <span class="n">result_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">result_df</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span><span class="n">result_row</span><span class="p">])],</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="n">result_row</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;Original File Path&quot;</span><span class="p">:</span> <span class="n">orig_file_path</span><span class="p">,</span><span class="s2">&quot;Reproduced File Path&quot;</span><span class="p">:</span> <span class="n">reproduce_file_path</span><span class="p">,</span><span class="s2">&quot;Field&quot;</span><span class="p">:</span> <span class="n">field</span><span class="p">,</span><span class="s2">&quot;Result&quot;</span><span class="p">:</span> <span class="s2">&quot;different&quot;</span><span class="p">}</span>
                    <span class="n">result_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">result_df</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span><span class="n">result_row</span><span class="p">])],</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="n">error_row</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;Original File Path&quot;</span><span class="p">:</span> <span class="n">orig_file_path</span><span class="p">,</span> <span class="s2">&quot;Reproduced File Path&quot;</span><span class="p">:</span> <span class="n">reproduce_file_path</span><span class="p">,</span>
                                 <span class="s2">&quot;Field&quot;</span><span class="p">:</span> <span class="n">field</span><span class="p">,</span> <span class="s2">&quot;Error Message&quot;</span><span class="p">:</span> <span class="s2">&quot;Failed to Bitwise comparison.&quot;</span><span class="p">}</span>
                    <span class="n">error_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">error_df</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span><span class="n">error_row</span><span class="p">])],</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">orig_file_path</span><span class="p">)</span> <span class="ow">and</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">reproduce_file_path</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">logger</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;original_file_path and reproduce_file_path are directories. Skipping check.&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;original_file_path and reproduce_file_path are directories. Skipping check.&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">orig_file_path</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">reproduce_file_path</span><span class="p">):</span>
                <span class="n">result_row</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;Original File Path&quot;</span><span class="p">:</span> <span class="n">orig_file_path</span><span class="p">,</span><span class="s2">&quot;Reproduced File Path&quot;</span><span class="p">:</span> <span class="n">reproduce_file_path</span><span class="p">,</span><span class="s2">&quot;Field&quot;</span><span class="p">:</span> <span class="n">field</span><span class="p">,</span><span class="s2">&quot;Result&quot;</span><span class="p">:</span> <span class="s2">&quot;error&quot;</span><span class="p">}</span>
                <span class="n">result_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">result_df</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span><span class="n">result_row</span><span class="p">])],</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">error_row</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;Original File Path&quot;</span><span class="p">:</span> <span class="n">orig_file_path</span><span class="p">,</span><span class="s2">&quot;Reproduced File Path&quot;</span><span class="p">:</span> <span class="n">reproduce_file_path</span><span class="p">,</span><span class="s2">&quot;Field&quot;</span><span class="p">:</span> <span class="n">field</span><span class="p">,</span>
                             <span class="s2">&quot;Error Message&quot;</span><span class="p">:</span> <span class="s2">&quot;The recorded paths don&#39;t exist&quot;</span><span class="p">}</span>
                <span class="n">error_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">error_df</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span><span class="n">error_row</span><span class="p">])],</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    
    <span class="c1"># File comparison result logging</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">error_df</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">logger</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">reproduced_dir</span><span class="p">)</span><span class="si">}</span><span class="s2">] - Some files are different! Compared original path:[</span><span class="si">{</span><span class="n">original_dir</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">reproduced_dir</span><span class="p">)</span><span class="si">}</span><span class="s2">] - Some files are different! Compared original path:[</span><span class="si">{</span><span class="n">original_dir</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">)</span>
        <span class="n">valid_code</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">logger</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">reproduced_dir</span><span class="p">)</span><span class="si">}</span><span class="s2">] - All files are identical! Compared original path:[</span><span class="si">{</span><span class="n">original_dir</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">reproduced_dir</span><span class="p">)</span><span class="si">}</span><span class="s2">] - All files are identical! Compared original path:[</span><span class="si">{</span><span class="n">original_dir</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">logger</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">reproduced_dir</span><span class="p">)</span><span class="si">}</span><span class="s2">] - Dataset comparison finished. Compared original path:[</span><span class="si">{</span><span class="n">original_dir</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">reproduced_dir</span><span class="p">)</span><span class="si">}</span><span class="s2">] - Dataset comparison finished. Compared original path:[</span><span class="si">{</span><span class="n">original_dir</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">valid_code</span><span class="p">,</span> <span class="n">result_df</span><span class="p">,</span> <span class="n">error_df</span></div>


<div class="viewcode-block" id="format_size">
<a class="viewcode-back" href="../../../gencap.utils.html#gencap.utils.helpers.format_size">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">format_size</span><span class="p">(</span><span class="n">size</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert a byte size to a human-readable format.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    size : int or float</span>
<span class="sd">        Size in bytes.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    str</span>
<span class="sd">        Formatted string with size and unit (B, KB, MB, GB, TB).</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; format_size(2048)</span>
<span class="sd">    &#39;2.00 KB&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">unit</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;KB&#39;</span><span class="p">,</span> <span class="s1">&#39;MB&#39;</span><span class="p">,</span> <span class="s1">&#39;GB&#39;</span><span class="p">,</span> <span class="s1">&#39;TB&#39;</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">size</span> <span class="o">&lt;</span> <span class="mi">1024</span><span class="p">:</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">size</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">unit</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">size</span> <span class="o">/=</span> <span class="mi">1024</span></div>

        
<div class="viewcode-block" id="get_username">
<a class="viewcode-back" href="../../../gencap.utils.html#gencap.utils.helpers.get_username">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_username</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Retrieve the current system username.</span>

<span class="sd">    This function attempts to retrieve the username using environment variables, </span>
<span class="sd">    `psutil`, or `os.getlogin`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    str</span>
<span class="sd">        Username of the current system user, or `&quot;unknown&quot;` if it cannot be determined.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; get_username()</span>
<span class="sd">    &#39;johndoe&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">user_name</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;USERNAME&quot;</span><span class="p">)</span> <span class="ow">or</span>
            <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;USER&quot;</span><span class="p">)</span> <span class="ow">or</span>
            <span class="n">psutil</span><span class="o">.</span><span class="n">Process</span><span class="p">()</span><span class="o">.</span><span class="n">username</span><span class="p">()</span> <span class="ow">or</span> 
            <span class="n">os</span><span class="o">.</span><span class="n">getlogin</span><span class="p">()</span>
        <span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
        <span class="n">user_name</span> <span class="o">=</span> <span class="s2">&quot;unknown&quot;</span>
    <span class="k">return</span> <span class="n">user_name</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Hye-Lim LEE (Epione team, Inria).</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>