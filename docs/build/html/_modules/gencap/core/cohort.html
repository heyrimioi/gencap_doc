

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>gencap.core.cohort &mdash; GENCAP 0.9.0-dev documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=6c04cfde"></script>
      <script src="../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            GENCAP
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">üõ†Ô∏è API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../modules.html">gencap</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">GENCAP</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">gencap.core.cohort</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for gencap.core.cohort</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span><span class="w"> </span><span class="nn">json</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">logging</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">Counter</span><span class="p">,</span> <span class="n">defaultdict</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">datetime</span><span class="w"> </span><span class="kn">import</span> <span class="n">datetime</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pathlib</span><span class="w"> </span><span class="kn">import</span> <span class="n">Path</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">IPython.display</span><span class="w"> </span><span class="kn">import</span> <span class="n">display</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">gencap.utils.helpers</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">find_dataset_path</span><span class="p">,</span>
    <span class="n">fix_mixed_column_types</span><span class="p">,</span>
    <span class="n">validate_dict_or_list_of_dict</span><span class="p">,</span>
    <span class="n">validate_values_are_dict</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">gencap.utils.dataset</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">check_col_type</span><span class="p">,</span>
    <span class="n">validate_required_files</span><span class="p">,</span>
    <span class="n">validate_data_description</span><span class="p">,</span>
    <span class="n">validate_data_content</span><span class="p">,</span>
    <span class="n">validate_file_existence</span>
<span class="p">)</span>


<span class="c1"># Define a custom exception that can store the dfError</span>
<div class="viewcode-block" id="CohortError">
<a class="viewcode-back" href="../../../gencap.core.html#gencap.CohortError">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">CohortError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Custom exception raised during cohort initialization or transformation.</span>

<span class="sd">    This exception captures error context and saves diagnostic information </span>
<span class="sd">    to `cohortErrorInformation.csv`.</span>

<span class="sd">    Args:</span>
<span class="sd">        message (str): Human-readable error description.</span>
<span class="sd">        df_error (pd.DataFrame): Error log dataframe with structured details.</span>
<span class="sd">        logger (logging.Logger): Logger instance used for error reporting.</span>

<span class="sd">    Side Effects:</span>
<span class="sd">        * Logs an error message with a link to the saved CSV file.</span>
<span class="sd">        * Displays the error dataframe in Jupyter/IPython environments.</span>
<span class="sd">        * Saves the dataframe as `cohortErrorInformation.csv`.</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; raise CohortError(&quot;Failed to merge datasets&quot;, dfError, logger)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">df_error</span><span class="p">,</span> <span class="n">logger</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">df_error</span> <span class="o">=</span> <span class="n">df_error</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">logger</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;üî¥ An error has occurred, and the process has been stopped. Please see </span><span class="si">{</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">(),</span><span class="s1">&#39;cohortErrorInformation.csv&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2"> for details.&quot;</span><span class="p">)</span>
        <span class="n">display</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df_error</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">df_error</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="s2">&quot;cohortErrorInformation.csv&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="ErrorConfig">
<a class="viewcode-back" href="../../../gencap.core.html#gencap.ErrorConfig">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ErrorConfig</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Configuration class defining standardized error codes used in Cohort operations.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        loadingFail (int): Error during dataset loading.</span>
<span class="sd">        validationFail (int): Error during dataset validation.</span>
<span class="sd">        transformationFail (int): Error during data transformation.</span>
<span class="sd">        mergeFail (int): Error during merging datasets.</span>
<span class="sd">        filteringFail (int): Error during filtering rows/columns.</span>
<span class="sd">        selectingFail (int): Error during dataset selection.</span>
<span class="sd">        indexingFieldInconsistent (int): Error due to inconsistent indexing fields.</span>
<span class="sd">        outputValidationFail (int): Error during final output validation.</span>
<span class="sd">        notSubset (int): Error when indexing fields are not subsets of each other.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># error codes : between 10-30 error during image collection phase</span>
    <span class="n">loadingFail</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="n">validationFail</span> <span class="o">=</span> <span class="mi">11</span>
    <span class="n">transformationFail</span> <span class="o">=</span> <span class="mi">12</span>
    <span class="n">mergeFail</span> <span class="o">=</span> <span class="mi">13</span>
    <span class="n">filteringFail</span> <span class="o">=</span> <span class="mi">14</span>
    <span class="n">selectingFail</span> <span class="o">=</span> <span class="mi">15</span>
    <span class="n">indexingFieldInconsistent</span><span class="o">=</span><span class="mi">16</span>
    <span class="n">outputValidationFail</span><span class="o">=</span><span class="mi">17</span>
    <span class="n">notSubset</span> <span class="o">=</span> <span class="mi">18</span></div>


<div class="viewcode-block" id="Cohort">
<a class="viewcode-back" href="../../../gencap.core.html#gencap.Cohort">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Cohort</span><span class="p">:</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A Cohort class represents a structured and unified view of one or more datasets for algorithmic processing.</span>

<span class="sd">    This class provides mechanisms to:</span>
<span class="sd">    - Load and validate multiple raw or derived datasets.</span>
<span class="sd">    - Apply standard transformations such as type casting, field renaming, value replacement, and column exclusion.</span>
<span class="sd">    - Merge datasets into a single DataFrame with consistent indexing fields.</span>
<span class="sd">    - Filter rows and columns based on field requirements or custom queries.</span>

<span class="sd">    Cohort objects serve as a critical interface between datasets and pipelines in the GENCAP framework:</span>
<span class="sd">    - From datasets: It retrieves and harmonizes tabular data (via `data_content.pkl`) and structural metadata (via `data_description.json`).</span>
<span class="sd">    - To pipelines: It exposes the final merged DataFrame, indexing fields, and file location fields needed for batch or iterative computation.</span>

<span class="sd">    Typical usage:</span>
<span class="sd">        &gt;&gt;&gt; cohort = Cohort(</span>
<span class="sd">        ...     datasetDir=&quot;/path/to/data&quot;,</span>
<span class="sd">        ...     datasetList=[&quot;dataset1&quot;, &quot;dataset2&quot;],</span>
<span class="sd">        ...     mandatoryFieldList=[&quot;Image File&quot;],</span>
<span class="sd">        ...     replaceValueDict={&quot;Gender&quot;: {&quot;M&quot;: &quot;Male&quot;, &quot;F&quot;: &quot;Female&quot;}},</span>
<span class="sd">        ...     queryString=&quot;Age &gt; 60&quot;</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; df = cohort.get_dataframe()</span>
<span class="sd">        &gt;&gt;&gt; pipeline.run(cohort, ...)</span>

<span class="sd">    The resulting Cohort enables standardized downstream processing, reproducibility, and traceability of computation pipelines.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">datasetDir</span><span class="p">,</span><span class="n">datasetList</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">tagList</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">fieldFormatDict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">additionalIndexingFieldDict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">additionalColumnFieldDict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">replaceValueDict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">changeFieldNamesDict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">excludeFieldList</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">mandatoryFieldList</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">optionalFieldList</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">excludeEntriesList</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">queryString</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">print_info</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize a :class:`Cohort` object by selecting, validating, transforming,</span>
<span class="sd">        merging, and filtering datasets into a unified dataframe.</span>

<span class="sd">        This constructor executes a **6-step initialization process**:</span>

<span class="sd">        1. **Select datasets** using `datasetList` and/or `tagList`.</span>
<span class="sd">        2. **Load datasets** and validate the presence of required files and structure.</span>
<span class="sd">        3. **Validate arguments** (field definitions, exclusion rules, query syntax).</span>
<span class="sd">        4. **Transform datasets** (format casting, renaming fields, value replacement, etc.).</span>
<span class="sd">        5. **Merge dataframes** by aligning multi-indexing fields and resolving conflicts.</span>
<span class="sd">        6. **Filter rows and columns**, then validate the final output dataframe.</span>

<span class="sd">        Args:</span>
<span class="sd">            datasetDir (str):</span>
<span class="sd">                Root directory where datasets are stored.</span>
<span class="sd">                Example: ``&quot;/path/to/datasets&quot;``</span>

<span class="sd">            datasetList (list[str], optional):</span>
<span class="sd">                Explicit list of dataset unique IDs to include.</span>
<span class="sd">                Example: ``[&quot;Dataset1&quot;, &quot;Dataset2&quot;]``</span>

<span class="sd">            tagList (list[str], optional):</span>
<span class="sd">                Tags used to filter datasets. If combined with `datasetList`, </span>
<span class="sd">                only datasets matching both conditions will be included.</span>
<span class="sd">                Example: ``[&quot;Prostate&quot;, &quot;Retrospective&quot;]``</span>

<span class="sd">            fieldFormatDict (dict | list[dict], optional):</span>
<span class="sd">                Specifies field type casting. Supports either a single dict (applied globally)</span>
<span class="sd">                or a list of dicts corresponding to each dataset.</span>
<span class="sd">                Example:</span>
<span class="sd">                    * Dict: ``{&quot;Age&quot;: &quot;int&quot;, &quot;ID&quot;: &quot;str&quot;}``</span>
<span class="sd">                    * List: ``[{&quot;Patient ID&quot;: &quot;str&quot;}, {}, {&quot;Visit ID&quot;: &quot;str&quot;}]``</span>

<span class="sd">            additionalIndexingFieldDict (dict | list[dict], optional):</span>
<span class="sd">                Constant fields to be added as **indexing fields**.</span>
<span class="sd">                Example:</span>
<span class="sd">                    * Dict: ``{&quot;Study Site&quot;: &quot;Hospital A&quot;}``</span>
<span class="sd">                    * List: ``[{&quot;Study Site&quot;: &quot;Hospital A&quot;}, {}, {&quot;Study Site&quot;: &quot;Hospital B&quot;}]``</span>

<span class="sd">            additionalColumnFieldDict (dict | list[dict], optional):</span>
<span class="sd">                Constant fields to be added as **columns** (non-index).</span>
<span class="sd">                Example:</span>
<span class="sd">                    * Dict: ``{&quot;Scanner&quot;: &quot;Siemens&quot;}``</span>

<span class="sd">            replaceValueDict (dict | list[dict], optional):</span>
<span class="sd">                Value replacement rules for fields.</span>
<span class="sd">                Example:</span>
<span class="sd">                    * Dict: ``{&quot;Gender&quot;: {&quot;M&quot;: &quot;Male&quot;, &quot;F&quot;: &quot;Female&quot;}}``</span>

<span class="sd">            changeFieldNamesDict (dict | list[dict], optional):</span>
<span class="sd">                Field renaming rules.</span>
<span class="sd">                Example:</span>
<span class="sd">                    * Dict: ``{&quot;pid&quot;: &quot;Patient ID&quot;}``</span>

<span class="sd">            excludeFieldList (list | list[list], optional):</span>
<span class="sd">                Fields to exclude, either globally or per-dataset.</span>
<span class="sd">                Example:</span>
<span class="sd">                    * Single list: ``[&quot;Series ID&quot;, &quot;Instance ID&quot;]``</span>
<span class="sd">                    * Per dataset: ``[[], [&quot;TempField&quot;], [&quot;DeprecatedField&quot;]]``</span>

<span class="sd">            mandatoryFieldList (list[str], optional):</span>
<span class="sd">                Fields required to be non-empty.</span>
<span class="sd">                Example: ``[&quot;Image File&quot;, &quot;Sequence&quot;]``</span>

<span class="sd">            optionalFieldList (list[str], optional):</span>
<span class="sd">                Optional fields to retain if present.</span>
<span class="sd">                Example: ``[&quot;Mask File&quot;, &quot;B-Value(s)&quot;]``</span>

<span class="sd">            excludeEntriesList (dict | list[tuple], optional):</span>
<span class="sd">                Conditions to exclude rows.</span>
<span class="sd">                Example:</span>
<span class="sd">                    * Dict (field-based): ``{&quot;SUBJECT_REF&quot;: [&quot;001-0009&quot;], &quot;Target ID&quot;: [&quot;2&quot;]}``</span>
<span class="sd">                    * List (multi-index): ``[(&quot;001-0020&quot;, &quot;001&quot;, &quot;12345678&quot;)]``</span>

<span class="sd">            queryString (str, optional):</span>
<span class="sd">                Pandas query string applied for row filtering.</span>
<span class="sd">                Example: ``&quot;Age &gt; 65 and Gender == &#39;Male&#39;&quot;``</span>

<span class="sd">            print_info (bool, optional):</span>
<span class="sd">                If True, enable verbose logging with detailed status messages.</span>

<span class="sd">        Raises:</span>
<span class="sd">            CohortError:</span>
<span class="sd">                Raised if dataset selection, validation, merging, or final output validation fails.</span>

<span class="sd">        Notes:</span>
<span class="sd">            * Logging behavior is controlled by `print_info`:</span>
<span class="sd">                - ``True``: INFO-level messages.</span>
<span class="sd">                - ``False``: Only ERROR-level messages.</span>
<span class="sd">            * On errors, a CSV (`cohortErrorInformation.csv`) is created with full details.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; cohort = Cohort(</span>
<span class="sd">            ...     datasetDir=&quot;/data&quot;,</span>
<span class="sd">            ...     datasetList=[&quot;Dataset1&quot;, &quot;Dataset2&quot;],</span>
<span class="sd">            ...     mandatoryFieldList=[&quot;Image File&quot;],</span>
<span class="sd">            ...     queryString=&quot;Age &gt; 60&quot;</span>
<span class="sd">            ... )</span>
<span class="sd">            &gt;&gt;&gt; print(cohort.get_dataframe().shape)</span>
<span class="sd">            (120, 8)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Store arguments</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">datasetDir</span> <span class="o">=</span> <span class="n">datasetDir</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">datasetList</span> <span class="o">=</span> <span class="n">datasetList</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tagList</span> <span class="o">=</span> <span class="n">tagList</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fieldFormatDict</span> <span class="o">=</span> <span class="n">fieldFormatDict</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">additionalIndexingFieldDict</span> <span class="o">=</span> <span class="n">additionalIndexingFieldDict</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">additionalColumnFieldDict</span> <span class="o">=</span> <span class="n">additionalColumnFieldDict</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">replaceValueDict</span> <span class="o">=</span> <span class="n">replaceValueDict</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">changeFieldNamesDict</span> <span class="o">=</span> <span class="n">changeFieldNamesDict</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">excludeFieldList</span> <span class="o">=</span> <span class="n">excludeFieldList</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">mandatoryFieldList</span> <span class="o">=</span> <span class="n">mandatoryFieldList</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">optionalFieldList</span> <span class="o">=</span> <span class="n">optionalFieldList</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">excludeEntriesList</span> <span class="o">=</span> <span class="n">excludeEntriesList</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">queryString</span> <span class="o">=</span> <span class="n">queryString</span>

        <span class="c1"># Initialize containers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dataframes</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">datadesc_dicts</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">datapaths</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">indexing_fields</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># Final indexing fields after merging</span>

        <span class="c1"># Initialize error containers</span>
        <span class="n">errorConfig</span><span class="o">=</span><span class="n">ErrorConfig</span><span class="p">()</span>
        <span class="n">errorColumnsList</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;Error Code&quot;</span><span class="p">,</span><span class="s2">&quot;Error Type&quot;</span><span class="p">,</span><span class="s2">&quot;Error Message&quot;</span><span class="p">,</span><span class="s2">&quot;Dataset Name&quot;</span><span class="p">,</span><span class="s2">&quot;Error Fields Name&quot;</span><span class="p">,</span><span class="s2">&quot;Index&quot;</span><span class="p">,</span><span class="s2">&quot;Value&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dfError</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">errorColumnsList</span><span class="p">)</span>

        <span class="c1"># Initialize log handler</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s2">&quot;Cohort&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">)</span>
        <span class="c1"># If there is an existing handler, remove it (to prevent duplication when re-invoked from a notebook, etc.)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">hasHandlers</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">handlers</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="c1"># Create a new StreamHandler</span>
        <span class="n">stream_handler</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">StreamHandler</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">print_info</span><span class="p">:</span>
            <span class="n">stream_handler</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">stream_handler</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">ERROR</span><span class="p">)</span>
        <span class="n">formatter</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">Formatter</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%(asctime)s</span><span class="s2"> - </span><span class="si">%(levelname)s</span><span class="s2"> - </span><span class="si">%(message)s</span><span class="s2">&quot;</span><span class="p">,</span>
                                      <span class="n">datefmt</span><span class="o">=</span><span class="s2">&quot;%Y-%m-</span><span class="si">%d</span><span class="s2"> %H:%M:%S&quot;</span><span class="p">)</span>
        <span class="n">stream_handler</span><span class="o">.</span><span class="n">setFormatter</span><span class="p">(</span><span class="n">formatter</span><span class="p">)</span>
        <span class="c1"># Registering a handler to the logger</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">addHandler</span><span class="p">(</span><span class="n">stream_handler</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Cohort is initialized.&quot;</span><span class="p">)</span>

        <span class="c1"># --- STEP 1 : Select Datasets to Combine ---</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Selecting the datasets...&quot;</span><span class="p">)</span>
        <span class="k">try</span> <span class="p">:</span>
            <span class="n">selected_datasets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_select_datasets</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dfError</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dfError</span><span class="p">)]</span><span class="o">=</span><span class="p">[</span><span class="n">errorConfig</span><span class="o">.</span><span class="n">selectingFail</span><span class="p">,</span><span class="s2">&quot;Dataset Selection Failure&quot;</span><span class="p">,</span><span class="n">e</span><span class="p">,</span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="s2">&quot;&quot;</span><span class="p">]</span>
            <span class="k">raise</span> <span class="n">CohortError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Failed to select datasets. </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dfError</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;‚úÖ Selected_dataset: </span><span class="si">{</span><span class="n">selected_datasets</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Loading the datasets...&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ds_name</span> <span class="ow">in</span> <span class="n">selected_datasets</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dataframes</span><span class="p">[</span><span class="n">ds_name</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">datadesc_dicts</span><span class="p">[</span><span class="n">ds_name</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">datapaths</span><span class="p">[</span><span class="n">ds_name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_dataset</span><span class="p">(</span><span class="n">ds_name</span><span class="p">)</span>      <span class="c1"># (User-implemented or library function)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;üîµ </span><span class="si">{</span><span class="n">ds_name</span><span class="si">}</span><span class="s2"> is loaded: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dataframes</span><span class="p">[</span><span class="n">ds_name</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> IndexingField: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">datadesc_dicts</span><span class="p">[</span><span class="n">ds_name</span><span class="p">][</span><span class="s1">&#39;indexingFieldList&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dfError</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dfError</span><span class="p">)]</span><span class="o">=</span><span class="p">[</span><span class="n">errorConfig</span><span class="o">.</span><span class="n">loadingFail</span><span class="p">,</span><span class="s2">&quot;Loading Fail&quot;</span><span class="p">,</span><span class="n">e</span><span class="p">,</span><span class="n">ds_name</span><span class="p">,</span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="s2">&quot;&quot;</span><span class="p">]</span>
                <span class="k">raise</span> <span class="n">CohortError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ds_name</span><span class="si">}</span><span class="s2"> - Failed to load. </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dfError</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;‚úÖ Data Loading is done.&quot;</span><span class="p">)</span>

        <span class="c1"># --- STEP 2 : Validate dataset and argument ---</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Validating arguments and the loaded datasets...&quot;</span><span class="p">)</span>
        <span class="c1"># Verify the input argument</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_validate_input_argument</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;üîµ Input arguments - Passed the validation process successfully&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">ds_name</span><span class="p">,</span> <span class="n">dataframe</span><span class="p">),</span> <span class="p">(</span> <span class="n">_</span><span class="p">,</span> <span class="n">datadesc_dict</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataframes</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">datadesc_dicts</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
            <span class="n">validation_result</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">validation_result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">validate_required_files</span><span class="p">(</span><span class="n">path</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">datapaths</span><span class="p">[</span><span class="n">ds_name</span><span class="p">]))</span>
                <span class="n">validation_result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">validate_data_description</span><span class="p">(</span><span class="n">path</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">datapaths</span><span class="p">[</span><span class="n">ds_name</span><span class="p">],</span><span class="n">dataframe</span><span class="o">=</span><span class="n">dataframe</span><span class="p">,</span><span class="n">data_desc</span><span class="o">=</span><span class="n">datadesc_dict</span><span class="p">))</span>
                <span class="n">validation_result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">validate_data_content</span><span class="p">(</span><span class="n">dataframe</span><span class="o">=</span><span class="n">dataframe</span><span class="p">,</span> <span class="n">data_desc</span><span class="o">=</span><span class="n">datadesc_dict</span><span class="p">))</span>
                <span class="n">validation_result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">validate_file_existence</span><span class="p">(</span><span class="n">dataframe</span><span class="o">=</span><span class="n">dataframe</span><span class="p">,</span> <span class="n">data_desc</span><span class="o">=</span><span class="n">datadesc_dict</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;üîµ </span><span class="si">{</span><span class="n">ds_name</span><span class="si">}</span><span class="s2"> - Passed the validation process successfully.&quot;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ds_name</span><span class="si">}</span><span class="s2"> - Failed to validate dataset. </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dfError</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dfError</span><span class="p">)]</span><span class="o">=</span><span class="p">[</span><span class="n">errorConfig</span><span class="o">.</span><span class="n">validationFail</span><span class="p">,</span><span class="s2">&quot;Validation Failed&quot;</span><span class="p">,</span><span class="n">e</span><span class="p">,</span><span class="n">ds_name</span><span class="p">,</span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="s2">&quot;&quot;</span><span class="p">]</span>
            <span class="k">if</span>  <span class="n">validation_result</span> <span class="o">!=</span> <span class="p">[</span><span class="kc">True</span><span class="p">]</span><span class="o">*</span><span class="mi">4</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">CohortError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Failure of the validation process. Check the dataset: </span><span class="si">{</span><span class="n">ds_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dfError</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;‚úÖ Validation is done.&quot;</span><span class="p">)</span>

        <span class="c1"># --- STEP 3 : Modify the Selected DataFrames ---</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Transforming the datasets...&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dataframes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">datadesc_dicts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_transformations</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataframes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">datadesc_dicts</span><span class="p">,</span> <span class="n">errorConfig</span><span class="p">)</span>
        <span class="c1"># Verify indexing fields if it&#39;s consistent before merging process.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_validate_indexing_field_consistency</span><span class="p">(</span><span class="n">errorConfig</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;üîµ Indexing fields are consistent.&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dfError</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dfError</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="s2">&quot;Error Message&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">e</span>
            <span class="k">raise</span> <span class="n">CohortError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Failed to validate indexing field consistency. </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dfError</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_validate_subset_index</span><span class="p">(</span><span class="n">errorConfig</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;üîµ Indexing fields are subset of the largest index.&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dfError</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dfError</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="s2">&quot;Error Message&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">e</span>
            <span class="k">raise</span> <span class="n">CohortError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Failed to validate subset relationship between indexing fields. </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dfError</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;‚úÖ Transformation is done.&quot;</span><span class="p">)</span>

        <span class="c1"># --- STEP 4 : Merge the DataFrames ---</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Merging the datasets...&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">final_df</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexing_fields</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_merge_dataframes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataframes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">datadesc_dicts</span><span class="p">,</span> <span class="n">errorConfig</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">file_location_fields</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_merge_file_location_fields</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;‚úÖ Merging the dataframes is done.&quot;</span><span class="p">)</span>

        <span class="c1"># --- STEP 5 : Filter Columns and Rows ---</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Filtering the datasets...&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">final_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filter_dataframe</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">final_df</span><span class="p">,</span> <span class="n">errorConfig</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">final_datadesc_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_generate_datadesc_dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Final dataframe shape: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">final_df</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;‚úÖ Filtering the dataframes is done.&quot;</span><span class="p">)</span>

        <span class="c1"># --- STEP 6 : Validate final dataframe ---</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_validate_output</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dfError</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dfError</span><span class="p">)]</span><span class="o">=</span><span class="p">[</span><span class="n">errorConfig</span><span class="o">.</span><span class="n">outputValidationFail</span><span class="p">,</span><span class="s2">&quot;Output validation Fail&quot;</span><span class="p">,</span><span class="n">e</span><span class="p">,</span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="s2">&quot;&quot;</span><span class="p">]</span>
            <span class="k">raise</span> <span class="n">CohortError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Final output - Failed to validate. </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dfError</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;‚úÖ The Cohort has been generated.&quot;</span><span class="p">)</span>

        <span class="c1"># remove cohortErrorInformation.csv if it exists.</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="s2">&quot;cohortErrorInformation.csv&quot;</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s2">&quot;cohortErrorInformation.csv&quot;</span><span class="p">)</span>
    <span class="c1"># -------------------------------------------------------------------------</span>
    <span class="c1"># Public interface methods</span>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="Cohort.get_dataframe">
<a class="viewcode-back" href="../../../gencap.core.html#gencap.Cohort.get_dataframe">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_dataframe</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieve the final merged and filtered cohort dataframe.</span>

<span class="sd">        This dataframe is produced after all processing steps:</span>
<span class="sd">        dataset selection, validation, transformation, merging,</span>
<span class="sd">        filtering, and final output validation.</span>

<span class="sd">        Returns:</span>
<span class="sd">            pd.DataFrame:</span>
<span class="sd">                The final dataframe containing the unified cohort data.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; cohort = Cohort(datasetDir=&quot;/path/to/data&quot;, datasetList=[&quot;Dataset1&quot;])</span>
<span class="sd">            &gt;&gt;&gt; df = cohort.get_dataframe()</span>
<span class="sd">            &gt;&gt;&gt; print(df.shape)</span>
<span class="sd">            (120, 8)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">final_df</span></div>


<div class="viewcode-block" id="Cohort.get_indexing_fields">
<a class="viewcode-back" href="../../../gencap.core.html#gencap.Cohort.get_indexing_fields">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_indexing_fields</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieve the indexing fields used for the final dataframe.</span>

<span class="sd">        Indexing fields are derived from the datasets included in the cohort</span>
<span class="sd">        and are validated to ensure consistency and subset relationships</span>
<span class="sd">        during the initialization process.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list[str]:</span>
<span class="sd">                List of indexing field names in the final cohort.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; cohort.get_indexing_fields()</span>
<span class="sd">            [&#39;Patient ID&#39;, &#39;Study ID&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">indexing_fields</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexing_fields</span> <span class="k">else</span> <span class="p">[]</span></div>


<div class="viewcode-block" id="Cohort.get_file_location_fields">
<a class="viewcode-back" href="../../../gencap.core.html#gencap.Cohort.get_file_location_fields">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_file_location_fields</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieve the file location fields from the cohort.</span>

<span class="sd">        File location fields represent columns that contain absolute file paths</span>
<span class="sd">        to complex data (e.g., images or reports) associated with cohort entries.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list[str]:</span>
<span class="sd">                A list of field names corresponding to file locations.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; cohort.get_file_location_fields()</span>
<span class="sd">            [&#39;Image File&#39;, &#39;Mask File&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">file_location_fields</span></div>


<div class="viewcode-block" id="Cohort.get_input_argument">
<a class="viewcode-back" href="../../../gencap.core.html#gencap.Cohort.get_input_argument">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_input_argument</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieve the input arguments used to initialize this cohort.</span>

<span class="sd">        This includes all configuration parameters such as dataset directory,</span>
<span class="sd">        dataset/tag filters, transformation rules, filtering options, and query strings.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict:</span>
<span class="sd">                Dictionary of all initialization arguments with their values.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; args = cohort.get_input_argument()</span>
<span class="sd">            &gt;&gt;&gt; print(args[&quot;datasetList&quot;])</span>
<span class="sd">            [&#39;Dataset1&#39;, &#39;Dataset2&#39;]</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">input_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;datasetDir&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">datasetDir</span><span class="p">,</span>
                      <span class="s2">&quot;datasetList&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">datasetList</span><span class="p">,</span>
                      <span class="s2">&quot;tagList&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">tagList</span><span class="p">,</span>
                      <span class="s2">&quot;fieldFormatDict&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">fieldFormatDict</span><span class="p">,</span>
                      <span class="s2">&quot;additionalIndexingFieldDict&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">additionalIndexingFieldDict</span><span class="p">,</span>
                      <span class="s2">&quot;additionalColumnFieldDict&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">additionalColumnFieldDict</span><span class="p">,</span>
                      <span class="s2">&quot;replaceValueDict&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">replaceValueDict</span><span class="p">,</span>
                      <span class="s2">&quot;changeFieldNamesDict&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">changeFieldNamesDict</span><span class="p">,</span>
                      <span class="s2">&quot;excludeFieldList&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">excludeFieldList</span><span class="p">,</span>
                      <span class="s2">&quot;mandatoryFieldList&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">mandatoryFieldList</span><span class="p">,</span>
                      <span class="s2">&quot;optionalFieldList&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">optionalFieldList</span><span class="p">,</span>
                      <span class="s2">&quot;excludeEntriesList&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">excludeEntriesList</span><span class="p">,</span>
                      <span class="s2">&quot;queryString&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">queryString</span><span class="p">}</span>
        <span class="k">return</span> <span class="n">input_dict</span></div>


    <span class="c1"># -------------------------------------------------------------------------</span>
    <span class="c1"># Internal helper methods</span>
    <span class="c1"># -------------------------------------------------------------------------</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_get_source_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">user</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">cohort_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate a ``data_source`` dictionary capturing provenance information</span>
<span class="sd">        for the cohort.</span>

<span class="sd">        This metadata tracks when and how the cohort was generated, </span>
<span class="sd">        including dataset sources and pipeline configuration placeholders.</span>

<span class="sd">        Args:</span>
<span class="sd">            user (str):</span>
<span class="sd">                Username or identifier of the individual generating the cohort.</span>
<span class="sd">            cohort_name (str):</span>
<span class="sd">                Name of the cohort.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict:</span>
<span class="sd">                Metadata about the cohort&#39;s origin, including:</span>

<span class="sd">                * **time (str)**: ISO 8601 timestamp of generation (e.g., &quot;2025-07-30T14:22:15&quot;).</span>
<span class="sd">                * **user (str)**: User who generated the cohort.</span>
<span class="sd">                * **cohortDatasetList (list[str])**: Included dataset names.</span>
<span class="sd">                * **pipelineID (str | None)**: Placeholder for associated pipeline ID (if applicable).</span>
<span class="sd">                * **pipelineVersion (str | None)**: Placeholder for pipeline version.</span>
<span class="sd">                * **pipelineParameterDict (dict | None)**: Placeholder for pipeline parameters.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; source = cohort._get_source_file(user=&quot;jdoe&quot;, cohort_name=&quot;Cohort-001&quot;)</span>
<span class="sd">            &gt;&gt;&gt; print(source[&quot;cohortDatasetList&quot;])</span>
<span class="sd">            [&#39;Dataset1&#39;, &#39;Dataset2&#39;]</span>

<span class="sd">        Notes:</span>
<span class="sd">            This dictionary is intended to be serialized as ``data_source.json`` </span>
<span class="sd">            in derived cohort outputs for reproducibility.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">source_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;time&quot;</span> <span class="p">:</span> <span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%Y-%m-</span><span class="si">%d</span><span class="s2">T%H:%M:%S&quot;</span><span class="p">),</span>
                     <span class="s2">&quot;user&quot;</span><span class="p">:</span> <span class="n">user</span><span class="p">,</span>
                      <span class="s2">&quot;cohortDatasetList&quot;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataframes</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span>
                      <span class="s2">&quot;pipelineID&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                      <span class="s2">&quot;pipelineVersion&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                      <span class="s2">&quot;pipelineParameterDict&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">}</span>
        <span class="k">return</span> <span class="n">source_dict</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_select_datasets</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Select datasets to include in the cohort based on ``datasetList`` </span>
<span class="sd">        and/or ``tagList``.</span>

<span class="sd">        The selection follows these rules:</span>

<span class="sd">        * If both ``datasetList`` and ``tagList`` are provided, only datasets</span>
<span class="sd">          present in both sets are included.</span>
<span class="sd">        * If only one is provided, it is used as the selection criteria.</span>
<span class="sd">        * If neither is provided, a ``ValueError`` is raised.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list[str]:</span>
<span class="sd">                List of selected dataset unique IDs.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError:</span>
<span class="sd">                If neither ``datasetList`` nor ``tagList`` is specified.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; cohort.datasetList = [&quot;Dataset1&quot;, &quot;Dataset2&quot;]</span>
<span class="sd">            &gt;&gt;&gt; cohort.tagList = [&quot;Prostate&quot;]</span>
<span class="sd">            &gt;&gt;&gt; selected = cohort._select_datasets()</span>
<span class="sd">            &gt;&gt;&gt; print(selected)</span>
<span class="sd">            [&#39;Dataset1&#39;]</span>

<span class="sd">        Notes:</span>
<span class="sd">            This method internally calls ``_sd_filter_dataset_by_tag`` if</span>
<span class="sd">            tag-based filtering is required.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">datasetList</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">filtered_dataset_datasetList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">datasetList</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tagList</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">filtered_dataset_tagList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sd_filter_dataset_by_tag</span><span class="p">()</span>

        <span class="c1"># Combine filters based on conditions</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">datasetList</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">tagList</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">filtered_dataset</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">filtered_dataset_datasetList</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">filtered_dataset_tagList</span><span class="p">)))</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">datasetList</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">tagList</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">filtered_dataset</span> <span class="o">=</span> <span class="n">filtered_dataset_datasetList</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">datasetList</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">tagList</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">filtered_dataset</span> <span class="o">=</span> <span class="n">filtered_dataset_tagList</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;At least one between datasetList and tagList should be specified.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">filtered_dataset</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_sd_filter_dataset_by_tag</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Filter datasets in ``self.datasetDir`` based on the provided ``tagList``.</span>

<span class="sd">        This method searches recursively for all ``data_description.json`` files </span>
<span class="sd">        within the dataset directory, reads their tag metadata, and selects datasets </span>
<span class="sd">        containing at least one of the tags specified in ``self.tagList``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list[str]:</span>
<span class="sd">                A list of dataset names (directory names) that match one or more tags </span>
<span class="sd">                in ``self.tagList``.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; cohort.tagList = [&quot;prostate&quot;, &quot;retrospective&quot;]</span>
<span class="sd">            &gt;&gt;&gt; matched = cohort._sd_filter_dataset_by_tag()</span>
<span class="sd">            &gt;&gt;&gt; print(matched)</span>
<span class="sd">            [&#39;Dataset1&#39;, &#39;Dataset3&#39;]</span>

<span class="sd">        Notes:</span>
<span class="sd">            * Tag comparison is **case-insensitive**.</span>
<span class="sd">            * Duplicate datasets matched by multiple tags are automatically deduplicated.</span>
<span class="sd">            * This method is internally used by :meth:`_select_datasets`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">filtered_dataset</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">found_json</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">file</span><span class="p">)</span> <span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">Path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">datasetDir</span><span class="p">)</span><span class="o">.</span><span class="n">rglob</span><span class="p">(</span><span class="s2">&quot;data_description.json&quot;</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">json_path</span> <span class="ow">in</span> <span class="n">found_json</span><span class="p">:</span>
            <span class="n">dataset_name</span> <span class="o">=</span> <span class="n">json_path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">datadesc_dict</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="n">json_path</span><span class="p">,</span><span class="s2">&quot;r&quot;</span><span class="p">))</span>
            <span class="n">datadesc_dict</span><span class="p">[</span><span class="s2">&quot;tagList&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">datadesc_dict</span><span class="p">[</span><span class="s2">&quot;tagList&quot;</span><span class="p">]]</span>
            <span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tagList</span><span class="p">:</span>
                <span class="n">tag</span> <span class="o">=</span> <span class="n">tag</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">datadesc_dict</span><span class="p">[</span><span class="s2">&quot;tagList&quot;</span><span class="p">]:</span>
                    <span class="n">filtered_dataset</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">dataset_name</span><span class="p">)</span>

        <span class="c1"># remove duplicated dataset by different tag</span>
        <span class="n">filtered_dataset</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">filtered_dataset</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">filtered_dataset</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_read_dataset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="nb">dict</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load a dataset&#39;s content and metadata from disk.</span>

<span class="sd">        This method locates the dataset directory, reads the ``data_content.pkl`` </span>
<span class="sd">        file into a pandas DataFrame, and loads the associated ``data_description.json``.</span>

<span class="sd">        Args:</span>
<span class="sd">            dataset_name (str):</span>
<span class="sd">                Unique identifier (folder name) of the dataset to load.</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple:</span>
<span class="sd">                * **pd.DataFrame**: The loaded dataset content.</span>
<span class="sd">                * **dict**: The parsed ``data_description.json`` metadata.</span>
<span class="sd">                * **str**: Absolute path to the dataset directory.</span>

<span class="sd">        Raises:</span>
<span class="sd">            FileNotFoundError:</span>
<span class="sd">                If the dataset path cannot be found, or required files </span>
<span class="sd">                (``data_content.pkl`` or ``data_description.json``) are missing.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; df, desc, path = cohort._read_dataset(&quot;Dataset1&quot;)</span>
<span class="sd">            &gt;&gt;&gt; print(df.shape)</span>
<span class="sd">            (120, 8)</span>
<span class="sd">            &gt;&gt;&gt; print(desc[&quot;indexingFieldList&quot;])</span>
<span class="sd">            [&#39;Patient ID&#39;, &#39;Study ID&#39;]</span>

<span class="sd">        Notes:</span>
<span class="sd">            * Relies on :func:`find_dataset_path` to resolve dataset directory paths.</span>
<span class="sd">            * Both ``data_content.pkl`` and ``data_description.json`` must be present </span>
<span class="sd">              for successful loading.</span>
<span class="sd">            * Logging includes the resolved dataset path and its indexing fields.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data_path</span> <span class="o">=</span> <span class="n">find_dataset_path</span><span class="p">(</span><span class="n">datasetName</span><span class="o">=</span><span class="n">dataset_name</span><span class="p">,</span><span class="n">databaseDir</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">datasetDir</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">data_path</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Configured path: </span><span class="si">{</span><span class="n">data_path</span><span class="si">}</span><span class="s2">. (Datasetdir:</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">datasetDir</span><span class="si">}</span><span class="s2">, dataset_name:</span><span class="si">{</span><span class="n">dataset_name</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_path</span><span class="p">,</span><span class="s2">&quot;data_content.pkl&quot;</span><span class="p">)):</span>
                <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_pickle</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_path</span><span class="p">,</span><span class="s2">&quot;data_content.pkl&quot;</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">FileNotFoundError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;File Path </span><span class="si">{</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_path</span><span class="p">,</span><span class="s1">&#39;data_content.pkl&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2"> does not exist.&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_path</span><span class="p">,</span><span class="s2">&quot;data_description.json&quot;</span><span class="p">)):</span>
                <span class="n">datadesc_dict</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_path</span><span class="p">,</span><span class="s1">&#39;data_description.json&#39;</span><span class="p">),</span><span class="s1">&#39;r&#39;</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">FileNotFoundError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;File Path </span><span class="si">{</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_path</span><span class="p">,</span><span class="s1">&#39;data_description.json&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2"> does not exist.&quot;</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">FileNotFoundError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Failed to find dataset path.&quot;</span><span class="p">)</span> 
        
        <span class="k">return</span> <span class="n">df</span><span class="p">,</span> <span class="n">datadesc_dict</span><span class="p">,</span> <span class="n">data_path</span>



    <span class="k">def</span><span class="w"> </span><span class="nf">_validate_input_argument</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Validate all input arguments provided during cohort initialization.</span>

<span class="sd">        This method ensures that the arguments (such as field formatting rules,</span>
<span class="sd">        indexing field additions, value replacements, exclusion lists, etc.) </span>
<span class="sd">        are of the correct type and structure. It also checks for invalid </span>
<span class="sd">        combinations or malformed values.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool:</span>
<span class="sd">                Returns ``True`` if all arguments pass validation.</span>

<span class="sd">        Raises:</span>
<span class="sd">            TypeError:</span>
<span class="sd">                Raised if any argument is of an incorrect type or contains</span>
<span class="sd">                improperly formatted values.</span>

<span class="sd">        Notes:</span>
<span class="sd">            * Validates dictionary or list-of-dictionaries formats using </span>
<span class="sd">              :func:`validate_dict_or_list_of_dict`.</span>
<span class="sd">            * Ensures that ``excludeEntriesList`` supports both dict-based and </span>
<span class="sd">              tuple-based multi-index filtering.</span>
<span class="sd">            * Checks that ``queryString`` is a valid string.</span>
<span class="sd">            * Updates are performed without modifying the argument values.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; cohort._validate_input_argument()</span>
<span class="sd">            True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fieldFormatDict</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">validate_dict_or_list_of_dict</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fieldFormatDict</span><span class="p">,</span>
                <span class="s2">&quot;fieldFormatDict&quot;</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dataframes</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fieldFormatDict</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
                <span class="n">check_keys</span><span class="o">=</span><span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fieldFormatDict</span><span class="p">,</span> <span class="nb">list</span><span class="p">),</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">additionalIndexingFieldDict</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">validate_dict_or_list_of_dict</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">additionalIndexingFieldDict</span><span class="p">,</span>
                <span class="s2">&quot;additionalIndexingFieldDict&quot;</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dataframes</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">additionalIndexingFieldDict</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
            <span class="p">)</span>
            
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">additionalColumnFieldDict</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">validate_dict_or_list_of_dict</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">additionalColumnFieldDict</span><span class="p">,</span>
                <span class="s2">&quot;additionalColumnFieldDict&quot;</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dataframes</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">additionalColumnFieldDict</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">replaceValueDict</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">validate_dict_or_list_of_dict</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">replaceValueDict</span><span class="p">,</span>
                <span class="s2">&quot;replaceValueDict&quot;</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dataframes</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">replaceValueDict</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">replaceValueDict</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">mapping</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">replaceValueDict</span><span class="p">:</span>
                    <span class="n">validate_values_are_dict</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="s2">&quot;replaceValueDict&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">validate_values_are_dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">replaceValueDict</span><span class="p">,</span> <span class="s2">&quot;replaceValueDict&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">changeFieldNamesDict</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">validate_dict_or_list_of_dict</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">changeFieldNamesDict</span><span class="p">,</span>
                <span class="s2">&quot;changeFieldNamesDict&quot;</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dataframes</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">changeFieldNamesDict</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
                <span class="n">check_keys</span><span class="o">=</span><span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">changeFieldNamesDict</span><span class="p">,</span> <span class="nb">list</span><span class="p">),</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">excludeFieldList</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">excludeFieldList</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;excludeFieldList must be a list or a list of lists.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span><span class="nb">str</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">excludeFieldList</span><span class="p">):</span>
                 <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;excludeFieldList must be a list or a list of lists.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mandatoryFieldList</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mandatoryFieldList</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;mandatoryFieldList must be a list.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">optionalFieldList</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">optionalFieldList</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;optionalFieldList must be a list.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">excludeEntriesList</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">excludeEntriesList</span><span class="p">,</span> <span class="p">(</span><span class="nb">dict</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;excludeEntriesList must be either a dictionary or a list of tuples.&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">excludeEntriesList</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">values</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">excludeEntriesList</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Values for key &#39;</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">&#39; in excludeEntriesList must be a list.&quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">values</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;All variables in excludeEntriesList must be strings.&quot;</span><span class="p">)</span>

            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">excludeEntriesList</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">entry</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">excludeEntriesList</span><span class="p">):</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Item </span><span class="si">{</span><span class="n">idx</span><span class="si">}</span><span class="s2"> in excludeEntriesList must be a tuple for multi-index filtering.&quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">entry</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;All variables in excludeEntriesList must be strings.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">queryString</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">queryString</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;queryString must be a string.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_validate_indexing_field_consistency</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">errorConfig</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Validate that all loaded dataframes share at least one common indexing field.</span>

<span class="sd">        This method inspects the index names across all datasets and checks </span>
<span class="sd">        if there is an intersection. If none exists, it records an error and raises </span>
<span class="sd">        a ``ValueError``.</span>

<span class="sd">        Args:</span>
<span class="sd">            errorConfig (ErrorConfig):</span>
<span class="sd">                Configuration object holding standardized error codes.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool:</span>
<span class="sd">                Returns ``True`` if at least one common indexing field exists.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError:</span>
<span class="sd">                If there are no common indexing fields among datasets.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Find common indices (intersections between all dataframes)</span>
        <span class="n">index_sets</span> <span class="o">=</span> <span class="p">[</span><span class="nb">set</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">names</span><span class="p">)</span> <span class="k">for</span> <span class="n">df</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataframes</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>
        <span class="n">common_index</span> <span class="o">=</span> <span class="nb">set</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="o">*</span><span class="n">index_sets</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">common_index</span><span class="p">)</span> <span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Combine all fields into one list</span>
            <span class="n">flat_fields</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">field</span> <span class="k">for</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="n">index_sets</span> <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">sublist</span><span class="p">])</span>
            <span class="c1"># Counting the number of index</span>
            <span class="n">field_counts</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">flat_fields</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dfError</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dfError</span><span class="p">)]</span><span class="o">=</span><span class="p">[</span><span class="n">errorConfig</span><span class="o">.</span><span class="n">indexingFieldInconsistent</span><span class="p">,</span><span class="s2">&quot;Indexing Fields Inconsistence&quot;</span><span class="p">,</span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataframes</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="s2">&quot;&quot;</span><span class="p">]</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No common indexing fields found. Field frequency: </span><span class="si">{</span><span class="n">field_counts</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_validate_subset_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">errorConfig</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Validate that each dataframe&#39;s index is a subset of the largest index.</span>

<span class="sd">        The largest index is determined as the dataframe with the greatest number </span>
<span class="sd">        of index levels. All other dataframes must have index fields that form </span>
<span class="sd">        a subset of this largest index.</span>

<span class="sd">        Args:</span>
<span class="sd">            errorConfig (ErrorConfig):</span>
<span class="sd">                Configuration object holding standardized error codes.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool:</span>
<span class="sd">                Returns ``True`` if all dataframes pass the subset index check.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError:</span>
<span class="sd">                If any dataframe&#39;s index is not a subset of the largest index.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># sort dataframes by number of index</span>
        <span class="n">sorted_dataframe_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_md_sort_dfs_by_index_count</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataframes</span><span class="p">,</span><span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># find the dataframe which has the largest index</span>
        <span class="n">max_index_dataframe</span> <span class="o">=</span> <span class="n">sorted_dataframe_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># check subset relationship</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">sorted_dataframe_list</span><span class="p">)):</span>
            <span class="n">ds_name</span> <span class="o">=</span> <span class="n">sorted_dataframe_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataframes</span><span class="p">[</span><span class="n">ds_name</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">names</span><span class="p">)</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span>
                   <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataframes</span><span class="p">[</span><span class="n">max_index_dataframe</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">names</span><span class="p">)):</span>
                <span class="n">difference</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataframes</span><span class="p">[</span><span class="n">ds_name</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">names</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataframes</span><span class="p">[</span><span class="n">max_index_dataframe</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">names</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dfError</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dfError</span><span class="p">)]</span><span class="o">=</span><span class="p">[</span><span class="n">errorConfig</span><span class="o">.</span><span class="n">notSubset</span><span class="p">,</span><span class="s2">&quot;Not subset relationship&quot;</span><span class="p">,</span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="n">ds_name</span><span class="p">,</span><span class="n">difference</span><span class="p">,</span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="s2">&quot;&quot;</span><span class="p">]</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Index of dataframe &#39;</span><span class="si">{</span><span class="n">ds_name</span><span class="si">}</span><span class="s2">&#39; must be a subset of the largest index (</span><span class="si">{</span><span class="n">max_index_dataframe</span><span class="si">}</span><span class="s2">).&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="kc">True</span>


    <span class="k">def</span><span class="w"> </span><span class="nf">_generate_datadesc_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate the final ``data_description`` dictionary for the cohort.</span>

<span class="sd">        This dictionary describes the unified cohort in a format consistent with</span>
<span class="sd">        GENCAP dataset specifications, including indexing fields, file location fields,</span>
<span class="sd">        tags, and the list of source datasets merged into the cohort.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict:</span>
<span class="sd">                A metadata dictionary with the following keys:</span>

<span class="sd">                * **uniqueID (str)**: Temporary identifier for the final cohort (default: &quot;Final Cohort&quot;).</span>
<span class="sd">                * **cohortDatasetList (list[str])**: Names of datasets merged into the cohort.</span>
<span class="sd">                * **indexingFieldList (list[str])**: Indexing fields used in the final cohort.</span>
<span class="sd">                * **fileLocationFieldList (list[str])**: Columns that represent file locations.</span>
<span class="sd">                * **tagList (list[str] | None)**: Tags propagated from input datasets or defined at initialization.</span>
<span class="sd">        Notes:</span>
<span class="sd">            * This temporary data description dictionary is used for the :func:`_validate_output`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">final_datadesc_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;uniqueID&quot;</span><span class="p">:</span><span class="s2">&quot;Final Cohort&quot;</span><span class="p">,</span>
                               <span class="s2">&quot;cohortDatasetList&quot;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataframes</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span>
                            <span class="s2">&quot;indexingFieldList&quot;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">indexing_fields</span><span class="p">),</span>
                            <span class="s2">&quot;fileLocationFieldList&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">file_location_fields</span><span class="p">,</span>
                            <span class="s2">&quot;tagList&quot;</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">tagList</span> <span class="p">}</span>
        <span class="k">return</span> <span class="n">final_datadesc_dict</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_validate_output</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Validate the integrity of the final cohort dataframe and metadata.</span>

<span class="sd">        This method performs multiple checks to ensure that the cohort is</span>
<span class="sd">        structurally sound and consistent with GENCAP standards:</span>

<span class="sd">        1. Ensures the final dataframe is non-empty.</span>
<span class="sd">        2. Validates content and metadata consistency using </span>
<span class="sd">           :func:`validate_data_content`.</span>
<span class="sd">        3. Confirms referenced files exist using :func:`validate_file_existence`.</span>
<span class="sd">        4. Validates column data types, auto-correcting mixed-type columns </span>
<span class="sd">           if necessary.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError:</span>
<span class="sd">                If the final dataframe is empty (invalid cohort).</span>
<span class="sd">            Exception:</span>
<span class="sd">                Propagates exceptions raised by validation functions if</span>
<span class="sd">                content or file checks fail.</span>

<span class="sd">        Notes:</span>
<span class="sd">            * If mixed-type columns are detected, they are automatically</span>
<span class="sd">              corrected using :func:`fix_mixed_column_types` and re-validated.</span>
<span class="sd">            * This step is executed at the end of cohort initialization.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">final_df</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid cohort: Final dataframe is empty.&quot;</span><span class="p">)</span>

        <span class="c1"># Validate content consistency with metadata</span>
        <span class="n">validate_data_content</span><span class="p">(</span><span class="n">dataframe</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">final_df</span><span class="p">,</span> <span class="n">data_desc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">final_datadesc_dict</span><span class="p">)</span>

        <span class="c1"># Validate referenced files exist</span>
        <span class="n">validate_file_existence</span><span class="p">(</span><span class="n">dataframe</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">final_df</span><span class="p">,</span> <span class="n">data_desc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">final_datadesc_dict</span><span class="p">)</span>

        <span class="c1"># Validate column types, fixing mixed types if necessary</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">check_col_type</span><span class="p">(</span><span class="n">dataframe</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">final_df</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">final_df</span> <span class="o">=</span> <span class="n">fix_mixed_column_types</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">final_df</span><span class="p">)</span>
            <span class="n">check_col_type</span><span class="p">(</span><span class="n">dataframe</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">final_df</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_apply_transformations</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">dataframes</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">],</span>
        <span class="n">datadesc_dicts</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">dict</span><span class="p">],</span>
        <span class="n">errorConfig</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">],</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">dict</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply transformations to the input datasets during cohort initialization.</span>

<span class="sd">        This method performs the following transformations sequentially:</span>

<span class="sd">        1. **Field format adjustments** (type casting)</span>
<span class="sd">        2. **Add constant fields** (index-level and column-level)</span>
<span class="sd">        3. **Replace values** in specific fields</span>
<span class="sd">        4. **Rename fields**</span>
<span class="sd">        5. **Exclude specified fields**</span>

<span class="sd">        Args:</span>
<span class="sd">            dataframes (dict[str, pd.DataFrame]):</span>
<span class="sd">                Dictionary mapping dataset names to their dataframes.</span>
<span class="sd">            datadesc_dicts (dict[str, dict]):</span>
<span class="sd">                Dictionary mapping dataset names to their metadata.</span>
<span class="sd">            errorConfig (ErrorConfig):</span>
<span class="sd">                Error configuration object to record transformation failures.</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple:</span>
<span class="sd">                * **dict[str, pd.DataFrame]**: Transformed dataframes.</span>
<span class="sd">                * **dict[str, dict]**: Updated metadata dictionaries.</span>

<span class="sd">        Notes:</span>
<span class="sd">            * If any transformation fails, an error is logged in `self.dfError` but the process continues.</span>
<span class="sd">            * Each transformation logs its effect when successful.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">modified_dataframes</span> <span class="o">=</span> <span class="n">dataframes</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">modified_datadesc_dicts</span> <span class="o">=</span> <span class="n">datadesc_dicts</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># 1. Field format adjustments</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fieldFormatDict</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">modified_dataframes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tf_transform_format_fields</span><span class="p">(</span><span class="n">modified_dataframes</span><span class="p">)</span>
            <span class="c1"># 2. Adding constant fields</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">additionalIndexingFieldDict</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">modified_dataframes</span><span class="p">,</span> <span class="n">modified_datadesc_dicts</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tf_add_constant_fields_index</span><span class="p">(</span><span class="n">modified_dataframes</span><span class="p">,</span><span class="n">modified_datadesc_dicts</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">additionalColumnFieldDict</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">modified_dataframes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tf_add_constant_fields_column</span><span class="p">(</span><span class="n">modified_dataframes</span><span class="p">)</span>
            <span class="c1"># 3. Replacing specific values</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">replaceValueDict</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">modified_dataframes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tf_replace_values</span><span class="p">(</span><span class="n">modified_dataframes</span><span class="p">)</span>
            <span class="c1"># 4. Renaming fields</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">changeFieldNamesDict</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">modified_dataframes</span><span class="p">,</span> <span class="n">modified_datadesc_dicts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tf_rename_fields</span><span class="p">(</span><span class="n">modified_dataframes</span><span class="p">,</span> <span class="n">modified_datadesc_dicts</span><span class="p">)</span>
            <span class="c1"># 5. Drop exclude fields</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">excludeFieldList</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">modified_dataframes</span><span class="p">,</span> <span class="n">modified_datadesc_dicts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tf_exclude_fields</span><span class="p">(</span><span class="n">modified_dataframes</span><span class="p">,</span> <span class="n">modified_datadesc_dicts</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Failed to transform. </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dfError</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dfError</span><span class="p">)]</span><span class="o">=</span><span class="p">[</span><span class="n">errorConfig</span><span class="o">.</span><span class="n">transformationFail</span><span class="p">,</span><span class="s2">&quot;Transformation Fail&quot;</span><span class="p">,</span><span class="n">e</span><span class="p">,</span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="s2">&quot;&quot;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">modified_dataframes</span><span class="p">,</span> <span class="n">modified_datadesc_dicts</span>


    <span class="k">def</span><span class="w"> </span><span class="nf">_tf_transform_format_fields</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataframes</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Cast field data types based on `fieldFormatDict`.</span>

<span class="sd">        Supports both a single dictionary (applied globally) and a list of dictionaries</span>
<span class="sd">        (applied per dataset).</span>

<span class="sd">        Args:</span>
<span class="sd">            dataframes (dict[str, pd.DataFrame]):</span>
<span class="sd">                Dictionary of dataset names to their dataframes.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict[str, pd.DataFrame]:</span>
<span class="sd">                Updated dataframes with field formats adjusted.</span>

<span class="sd">        Notes:</span>
<span class="sd">            * Logs which fields were successfully type-cast.</span>
<span class="sd">            * Uses `astype(errors=&quot;ignore&quot;)` to avoid crashes on incompatible casts.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fieldFormatDict</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">df</span> <span class="ow">in</span> <span class="n">dataframes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">indexField</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">names</span>
                <span class="n">df</span><span class="o">=</span><span class="n">df</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
                <span class="n">success_fields</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">field</span><span class="p">,</span> <span class="n">dtype</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fieldFormatDict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                        <span class="n">df</span><span class="p">[</span><span class="n">field</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">field</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>
                        <span class="n">success_fields</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">field</span><span class="p">)</span>
                <span class="n">dataframes</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="n">indexField</span><span class="p">,</span><span class="n">verify_integrity</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">success_fields</span><span class="p">)</span> <span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;üîµ </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> - Field format(s) </span><span class="si">{</span><span class="n">success_fields</span><span class="si">}</span><span class="s2"> have been modified. Input fieldFormatDict: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">fieldFormatDict</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fieldFormatDict</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dataframes</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fieldFormatDict</span><span class="p">):</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">df</span><span class="p">),</span> <span class="n">fieldFormat_dict</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">dataframes</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">fieldFormatDict</span><span class="p">):</span>
                    <span class="n">indexField</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">names</span>
                    <span class="n">df</span><span class="o">=</span><span class="n">df</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fieldFormat_dict</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                        <span class="k">for</span> <span class="n">field</span><span class="p">,</span> <span class="n">dtype</span> <span class="ow">in</span> <span class="n">fieldFormat_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                            <span class="k">if</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                                <span class="n">df</span><span class="p">[</span><span class="n">field</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">field</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;üîµ </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> - Field format(s) have been modified. Input fieldFormatDict: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">fieldFormatDict</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="n">dataframes</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="n">indexField</span><span class="p">,</span><span class="n">verify_integrity</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>


        <span class="k">return</span> <span class="n">dataframes</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_tf_add_constant_fields_index</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">dataframes</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">],</span>
        <span class="n">datadesc_dicts</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">dict</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">],</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">dict</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add index field with constant value to the dataframe.</span>

<span class="sd">        Args:</span>
<span class="sd">            dataframes (dict[str, pd.DataFrame]):</span>
<span class="sd">                Dictionary of dataset names to their dataframes.</span>
<span class="sd">            datadesc_dicts (dict[str, dict]):</span>
<span class="sd">                Metadata dictionaries associated with each dataset.</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple:</span>
<span class="sd">                * **dict[str, pd.DataFrame]**: Dataframes with new index fields.</span>
<span class="sd">                * **dict[str, dict]**: Updated metadata with new indexing fields.</span>

<span class="sd">        Notes:</span>
<span class="sd">            * If a field already exists in the index, it will not be added again.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">additionalIndexingFieldDict</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">df</span><span class="p">),</span> <span class="n">desc</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">dataframes</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">datadesc_dicts</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
                <span class="k">for</span> <span class="n">field</span><span class="p">,</span> <span class="n">const_value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">additionalIndexingFieldDict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">field</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">names</span><span class="p">):</span>
                        <span class="n">df</span><span class="p">[</span><span class="n">field</span><span class="p">]</span> <span class="o">=</span> <span class="n">const_value</span>
                        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                        <span class="n">desc</span><span class="p">[</span><span class="s2">&quot;indexingFieldList&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">field</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;üîµ </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> - Constant values have been added on the indexing fields. Input additionalIndexingFieldDict: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">additionalIndexingFieldDict</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">dataframes</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span>
                <span class="n">datadesc_dicts</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">desc</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">additionalIndexingFieldDict</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dataframes</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">additionalIndexingFieldDict</span><span class="p">):</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">df</span><span class="p">),</span> <span class="n">additionalField_dict</span><span class="p">,</span> <span class="n">desc</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">dataframes</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">additionalIndexingFieldDict</span><span class="p">,</span> <span class="n">datadesc_dicts</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">additionalField_dict</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                        <span class="k">for</span> <span class="n">field</span><span class="p">,</span> <span class="n">const_value</span> <span class="ow">in</span> <span class="n">additionalField_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                            <span class="k">if</span> <span class="n">field</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">names</span><span class="p">):</span>
                                <span class="n">df</span><span class="p">[</span><span class="n">field</span><span class="p">]</span> <span class="o">=</span> <span class="n">const_value</span>
                                <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                                <span class="n">desc</span><span class="p">[</span><span class="s2">&quot;indexingFieldList&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">field</span><span class="p">)</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;üîµ </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> - Constant values have been added on the indexing fields. Input additionalIndexingFieldDict: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">additionalIndexingFieldDict</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="n">dataframes</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span>
                        <span class="n">datadesc_dicts</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">desc</span>
        <span class="k">return</span> <span class="n">dataframes</span><span class="p">,</span> <span class="n">datadesc_dicts</span>
    
    <span class="k">def</span><span class="w"> </span><span class="nf">_tf_add_constant_fields_column</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataframes</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add column field with constant value to dataframes.</span>

<span class="sd">        Args:</span>
<span class="sd">            dataframes (dict[str, pd.DataFrame]):</span>
<span class="sd">                Dictionary of dataset names to their dataframes.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict[str, pd.DataFrame]:</span>
<span class="sd">                Dataframes with added constant columns.</span>

<span class="sd">        Notes:</span>
<span class="sd">            * Skips adding a column if it already exists.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">additionalColumnFieldDict</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">df</span> <span class="ow">in</span> <span class="n">dataframes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">field</span><span class="p">,</span> <span class="n">const_value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">additionalColumnFieldDict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">field</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
                        <span class="n">df</span><span class="p">[</span><span class="n">field</span><span class="p">]</span> <span class="o">=</span> <span class="n">const_value</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;üîµ </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> - Constant values have been added on the column fields. Input additionalColumnFieldDict: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">additionalColumnFieldDict</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">dataframes</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">additionalColumnFieldDict</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dataframes</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">additionalColumnFieldDict</span><span class="p">):</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">df</span><span class="p">),</span> <span class="n">additionalField_dict</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">dataframes</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">additionalColumnFieldDict</span><span class="p">):</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">additionalField_dict</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                        <span class="k">for</span> <span class="n">field</span><span class="p">,</span> <span class="n">const_value</span> <span class="ow">in</span> <span class="n">additionalField_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                            <span class="k">if</span> <span class="n">field</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
                                <span class="n">df</span><span class="p">[</span><span class="n">field</span><span class="p">]</span> <span class="o">=</span> <span class="n">const_value</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;üîµ </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> - Constant values have been added on the column fields. Input additionalColumnFieldDict: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">additionalColumnFieldDict</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="n">dataframes</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span>
        <span class="k">return</span> <span class="n">dataframes</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_tf_replace_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataframes</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Replace specific values in dataframe fields based on `replaceValueDict`.</span>

<span class="sd">        Args:</span>
<span class="sd">            dataframes (dict[str, pd.DataFrame]):</span>
<span class="sd">                Dictionary of dataset names to their dataframes.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict[str, pd.DataFrame]:</span>
<span class="sd">                Dataframes with specified values replaced.</span>

<span class="sd">        Notes:</span>
<span class="sd">            * Supports both global replacement dict and per-dataset list of dicts.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">replaceValueDict</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">df</span> <span class="ow">in</span> <span class="n">dataframes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">indexField</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">names</span>
                <span class="n">df</span><span class="o">=</span><span class="n">df</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">field</span><span class="p">,</span> <span class="n">replace_map</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">replaceValueDict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                        <span class="n">df</span><span class="p">[</span><span class="n">field</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">field</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">replace_map</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;üîµ </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> - Some values have been replaced. Input replaceValueDict: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">replaceValueDict</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">dataframes</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="n">indexField</span><span class="p">,</span><span class="n">verify_integrity</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">replaceValueDict</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dataframes</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">replaceValueDict</span><span class="p">):</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">df</span><span class="p">),</span> <span class="n">replaceValue_dict</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">dataframes</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">replaceValueDict</span><span class="p">):</span>
                    <span class="n">indexField</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">names</span>
                    <span class="n">df</span><span class="o">=</span><span class="n">df</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">replaceValue_dict</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                        <span class="k">for</span> <span class="n">field</span><span class="p">,</span> <span class="n">replace_map</span> <span class="ow">in</span> <span class="n">replaceValue_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">replace_map</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                                <span class="k">if</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                                    <span class="n">df</span><span class="p">[</span><span class="n">field</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">field</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">replace_map</span><span class="p">)</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;üîµ </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> - Some values have been replaced. Input replaceValueDict: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">replaceValueDict</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="n">dataframes</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="n">indexField</span><span class="p">,</span><span class="n">verify_integrity</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dataframes</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_tf_rename_fields</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">dataframes</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">],</span>
        <span class="n">datadesc_dicts</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">dict</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">],</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">dict</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rename fields (columns and indices) in the dataframes.</span>

<span class="sd">        Args:</span>
<span class="sd">            dataframes (dict[str, pd.DataFrame]):</span>
<span class="sd">                Dictionary of dataset names to their dataframes.</span>
<span class="sd">            datadesc_dicts (dict[str, dict]):</span>
<span class="sd">                Corresponding dataset metadata dictionaries.</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple:</span>
<span class="sd">                * **dict[str, pd.DataFrame]**: Dataframes with renamed fields.</span>
<span class="sd">                * **dict[str, dict]**: Updated metadata with renamed indexing and file fields.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">changeFieldNamesDict</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">df</span><span class="p">),</span> <span class="n">desc</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">dataframes</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">datadesc_dicts</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
                <span class="n">indexingFieldList</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>
                <span class="n">fileLocationFieldList</span> <span class="o">=</span> <span class="n">desc</span><span class="p">[</span><span class="s2">&quot;fileLocationFieldList&quot;</span><span class="p">]</span>

                <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
                <span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">changeFieldNamesDict</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">indexingFieldList</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">changeFieldNamesDict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span><span class="n">indexingFieldList</span><span class="p">))</span>
                <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="n">indexingFieldList</span><span class="p">,</span> <span class="n">verify_integrity</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">fileLocationFieldList</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">desc</span><span class="p">[</span><span class="s2">&quot;fileLocationFieldList&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">changeFieldNamesDict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span><span class="n">fileLocationFieldList</span><span class="p">))</span>
                <span class="k">if</span> <span class="s2">&quot;indexingFieldList&quot;</span> <span class="ow">in</span> <span class="n">desc</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">desc</span><span class="p">[</span><span class="s2">&quot;indexingFieldList&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">indexingFieldList</span>
                <span class="n">dataframes</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span>
                <span class="n">datadesc_dicts</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">desc</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;üîµ </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> - name of field has been renamed. Input changeFieldNamesDict: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">changeFieldNamesDict</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">changeFieldNamesDict</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">changeFieldNamesDict</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">dataframes</span><span class="p">):</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">df</span><span class="p">),</span> <span class="n">desc</span><span class="p">,</span> <span class="n">changeFieldNames_dict</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">dataframes</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">datadesc_dicts</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">changeFieldNamesDict</span><span class="p">):</span>
                    <span class="n">indexingFieldList</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>
                    <span class="n">fileLocationFieldList</span> <span class="o">=</span> <span class="n">desc</span><span class="p">[</span><span class="s2">&quot;fileLocationFieldList&quot;</span><span class="p">]</span>

                    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
                    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">changeFieldNames_dict</span><span class="p">)</span>
                    <span class="n">indexingFieldList</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">changeFieldNames_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span><span class="n">indexingFieldList</span><span class="p">))</span>
                    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="n">indexingFieldList</span><span class="p">,</span> <span class="n">verify_integrity</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">fileLocationFieldList</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">desc</span><span class="p">[</span><span class="s2">&quot;fileLocationFieldList&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">changeFieldNames_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span><span class="n">fileLocationFieldList</span><span class="p">))</span>
                    <span class="k">if</span> <span class="s2">&quot;indexingFieldList&quot;</span> <span class="ow">in</span> <span class="n">desc</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                        <span class="n">desc</span><span class="p">[</span><span class="s2">&quot;indexingFieldList&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">indexingFieldList</span>
                    <span class="n">dataframes</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span>
                    <span class="n">datadesc_dicts</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">desc</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;üîµ </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> - name of field has been renamed. Input changeFieldNamesDict: </span><span class="si">{</span><span class="n">changeFieldNames_dict</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dataframes</span><span class="p">,</span> <span class="n">datadesc_dicts</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_tf_exclude_fields</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">dataframes</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">],</span>
        <span class="n">datadesc_dicts</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">dict</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">],</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">dict</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Exclude specified fields from the dataframes and update metadata.</span>

<span class="sd">        Args:</span>
<span class="sd">            dataframes (dict[str, pd.DataFrame]):</span>
<span class="sd">                Dictionary mapping dataset names to their dataframes.</span>
<span class="sd">            datadesc_dicts (dict[str, dict]):</span>
<span class="sd">                Metadata dictionaries for each dataset.</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple:</span>
<span class="sd">                * **dict[str, pd.DataFrame]**: Dataframes with fields removed.</span>
<span class="sd">                * **dict[str, dict]**: Updated metadata reflecting field removals.</span>

<span class="sd">        Notes:</span>
<span class="sd">            * Handles both single list and list-of-lists exclusion formats.</span>
<span class="sd">            * Automatically updates `fileLocationFieldList` and `indexingFieldList`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">excludeFieldList</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">excludeFieldList</span><span class="p">):</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">df</span><span class="p">),</span> <span class="n">desc</span><span class="p">,</span> <span class="n">excludeField_list</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">dataframes</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">datadesc_dicts</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">excludeFieldList</span><span class="p">):</span>
                <span class="k">if</span> <span class="s2">&quot;fileLocationFieldList&quot;</span> <span class="ow">in</span> <span class="n">desc</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">fileLocationFieldList</span> <span class="o">=</span> <span class="n">desc</span><span class="p">[</span><span class="s2">&quot;fileLocationFieldList&quot;</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">fileLocationFieldList</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">excludeField_list</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
                        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">col</span><span class="p">)</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">col</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">fileLocationFieldList</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">fileLocationFieldList</span><span class="p">:</span>
                            <span class="n">fileLocationFieldList</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>
                <span class="n">desc</span><span class="p">[</span><span class="s2">&quot;fileLocationFieldList&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fileLocationFieldList</span>
                <span class="k">if</span> <span class="s2">&quot;indexingFieldList&quot;</span> <span class="ow">in</span> <span class="n">desc</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">desc</span><span class="p">[</span><span class="s2">&quot;indexingFieldList&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">names</span>
                <span class="n">dataframes</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span>
                <span class="n">datadesc_dicts</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">desc</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;üîµ </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> - Selected fields were excluded. Input excludeFieldList: </span><span class="si">{</span><span class="n">excludeField_list</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">excludeFieldList</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">df</span><span class="p">),</span> <span class="n">desc</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">dataframes</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">datadesc_dicts</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
                <span class="k">if</span> <span class="s2">&quot;fileLocationFieldList&quot;</span> <span class="ow">in</span> <span class="n">desc</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">fileLocationFieldList</span> <span class="o">=</span> <span class="n">desc</span><span class="p">[</span><span class="s2">&quot;fileLocationFieldList&quot;</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">fileLocationFieldList</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">excludeFieldList</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
                        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">col</span><span class="p">)</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">col</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">fileLocationFieldList</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">fileLocationFieldList</span><span class="p">:</span>
                            <span class="n">fileLocationFieldList</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>
                <span class="n">desc</span><span class="p">[</span><span class="s2">&quot;fileLocationFieldList&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fileLocationFieldList</span>
                <span class="k">if</span> <span class="s2">&quot;indexingFieldList&quot;</span> <span class="ow">in</span> <span class="n">desc</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">desc</span><span class="p">[</span><span class="s2">&quot;indexingFieldList&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">names</span>
                <span class="n">dataframes</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span>
                <span class="n">datadesc_dicts</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">desc</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;üîµ </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> - Selected fields were excluded. Input excludeFieldList: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">excludeFieldList</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dataframes</span><span class="p">,</span> <span class="n">datadesc_dicts</span>
    
    <span class="k">def</span><span class="w"> </span><span class="nf">_merge_dataframes</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">dataframes</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">],</span>
        <span class="n">datadesc_dicts</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">dict</span><span class="p">],</span>
        <span class="n">errorConfig</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Merge multiple datasets into a single dataframe with consistent indexing fields.</span>

<span class="sd">        This function performs a **two-stage merge**:</span>

<span class="sd">        1. **Within-group merge**: </span>
<span class="sd">           Groups datasets that share the same indexing fields and merges them while handling conflicting columns.</span>
<span class="sd">        2. **Between-group merge**:</span>
<span class="sd">           Combines grouped datasets with different indexing fields (superset-subset relationships).</span>

<span class="sd">        Args:</span>
<span class="sd">            dataframes (dict[str, pd.DataFrame]):</span>
<span class="sd">                A dictionary mapping dataset names to their corresponding dataframes.</span>
<span class="sd">            datadesc_dicts (dict[str, dict]):</span>
<span class="sd">                A dictionary mapping dataset names to their metadata descriptions.</span>
<span class="sd">            errorConfig (ErrorConfig):</span>
<span class="sd">                Error configuration object for standardized error logging.</span>

<span class="sd">        Returns:</span>
<span class="sd">            * **pd.DataFrame**: The merged dataframe combining all datasets.</span>
<span class="sd">            * **list[str]**: The final indexing fields used in the merged dataframe.</span>

<span class="sd">        Raises:</span>
<span class="sd">            CohortError:</span>
<span class="sd">                If merging fails within a group or between groups due to conflicts or invalid operations.</span>

<span class="sd">        Notes:</span>
<span class="sd">            * Indexing fields are inferred based on the dataset with the most levels of indexing.</span>
<span class="sd">            * Conflicts within groups raise an error with detailed logging in `self.dfError`.</span>
<span class="sd">            * Between-group conflicts are resolved by prioritizing the dataset with the larger index.</span>
<span class="sd">        &quot;&quot;&quot;</span>


        <span class="c1"># Step 1: Group datasets by index</span>
        <span class="n">grouped_dataframes</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="n">sorted_dataframes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_md_sort_dfs_by_index_count</span><span class="p">(</span><span class="n">dataframes</span><span class="p">)</span>
        <span class="c1"># Final index (largest index)</span>
        <span class="n">indexing_fields</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">dataframes</span><span class="p">[</span><span class="n">sorted_dataframes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">ds_name</span> <span class="ow">in</span> <span class="n">sorted_dataframes</span><span class="p">:</span>
            <span class="n">prefix</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">dataframes</span><span class="p">[</span><span class="n">ds_name</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">names</span><span class="p">))</span><span class="si">}</span><span class="s2">&quot;</span>  <span class="c1"># Extract the prefix before first `_`</span>
            <span class="n">grouped_dataframes</span><span class="p">[</span><span class="n">prefix</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">ds_name</span><span class="p">,</span> <span class="n">dataframes</span><span class="p">[</span><span class="n">ds_name</span><span class="p">]))</span>

        <span class="c1"># Step 2: Merge DataFrames within each group first</span>
        <span class="n">merged_groups</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">prefix</span><span class="p">,</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">grouped_dataframes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Merging dataset which has index </span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">ds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">ds</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">group</span><span class="p">])</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">merged_group_df</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">ds_name</span><span class="p">,</span> <span class="n">df</span> <span class="ow">in</span> <span class="n">group</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">merged_group_df</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">merged_group_df</span> <span class="o">=</span> <span class="n">df</span>
                        <span class="n">prev_ds_name</span> <span class="o">=</span> <span class="n">ds_name</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">merged_group_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_md_combine_first_with_conflict_cols</span><span class="p">(</span><span class="n">merged_group_df</span><span class="p">,</span><span class="n">df</span><span class="p">,</span> <span class="n">prev_ds_name</span><span class="p">,</span> <span class="n">ds_name</span><span class="p">,</span><span class="n">errorConfig</span><span class="p">,</span><span class="n">same_group</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                        <span class="n">prev_ds_name</span> <span class="o">=</span> <span class="n">ds_name</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;‚úÖ </span><span class="si">{</span><span class="n">ds_name</span><span class="si">}</span><span class="s2"> merged successfully (Shape: </span><span class="si">{</span><span class="n">merged_group_df</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">CohortError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ds_name</span><span class="si">}</span><span class="s2"> - Failed to merge within group. </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dfError</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span>
            <span class="n">merged_groups</span><span class="p">[</span><span class="n">prefix</span><span class="p">]</span> <span class="o">=</span> <span class="n">merged_group_df</span>

        <span class="c1"># Step 3: Merge all grouped DataFrames together</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Merging datasets into final dataframe. Grouped index: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">grouped_dataframes</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">merged_df</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">prefix</span><span class="p">,</span> <span class="n">df</span> <span class="ow">in</span> <span class="n">merged_groups</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">merged_df</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">merged_df</span> <span class="o">=</span> <span class="n">df</span>
                    <span class="n">prev_ds_name</span> <span class="o">=</span> <span class="n">prefix</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">merged_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_md_combine_first_with_conflict_cols</span><span class="p">(</span><span class="n">merged_df</span><span class="p">,</span><span class="n">df</span><span class="p">,</span> <span class="n">prev_ds_name</span><span class="p">,</span> <span class="n">prefix</span><span class="p">,</span><span class="n">errorConfig</span><span class="p">,</span><span class="n">same_group</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                    <span class="n">prev_ds_name</span> <span class="o">=</span> <span class="n">prefix</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;‚úÖ Merged dataset which has index </span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2"> into final DataFrame (Shape: </span><span class="si">{</span><span class="n">merged_df</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dfError</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dfError</span><span class="p">)]</span> <span class="o">=</span> <span class="p">[</span><span class="n">errorConfig</span><span class="o">.</span><span class="n">mergeFail</span><span class="p">,</span> <span class="s2">&quot;Merge Fail&quot;</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">prefix</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">]</span>
                <span class="k">raise</span> <span class="n">CohortError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Group [</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">] - Failed to merge into final DataFrame. </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dfError</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">indexing_fields</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">merged_df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">names</span><span class="p">))</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">indexing_fields</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">merged_df</span> <span class="o">=</span> <span class="n">merged_df</span><span class="o">.</span><span class="n">reorder_levels</span><span class="p">(</span><span class="n">indexing_fields</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">merged_df</span><span class="p">,</span> <span class="n">indexing_fields</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_md_combine_first_with_conflict_cols</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">df_left</span><span class="p">,</span><span class="n">df_right</span><span class="p">,</span> <span class="n">df_left_name</span><span class="p">,</span> <span class="n">df_right_name</span><span class="p">,</span><span class="n">errorConfig</span><span class="p">,</span><span class="n">same_group</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Merge two dataframes while handling column conflicts based on indexing fields.</span>

<span class="sd">        Behavior differs depending on whether the dataframes share the same indexing fields:</span>

<span class="sd">        **Case 1: Same indexing fields (within-group)**</span>
<span class="sd">            * Conflicting columns are renamed (suffix `_right` added).</span>
<span class="sd">            * Conflict details (indices and values) are logged in `self.dfError`.</span>
<span class="sd">            * A `ValueError` is raised to enforce explicit conflict resolution.</span>

<span class="sd">        **Case 2: Different indexing fields (between-groups)**</span>
<span class="sd">            * Conflicting columns are dropped from the left dataframe.</span>
<span class="sd">            * Right dataframe values take precedence.</span>

<span class="sd">        Args:</span>
<span class="sd">            df_left (pd.DataFrame):</span>
<span class="sd">                Left dataframe in the merge.</span>
<span class="sd">            df_right (pd.DataFrame):</span>
<span class="sd">                Right dataframe in the merge.</span>
<span class="sd">            df_left_name (str):</span>
<span class="sd">                Identifier for `df_left` (used for logging and error messages).</span>
<span class="sd">            df_right_name (str):</span>
<span class="sd">                Identifier for `df_right`.</span>
<span class="sd">            errorConfig (ErrorConfig):</span>
<span class="sd">                Error configuration object for conflict logging.</span>
<span class="sd">            same_group (bool, optional):</span>
<span class="sd">                Indicates if the merge is within a group (same index) or between groups (default: True).</span>

<span class="sd">        Returns:</span>
<span class="sd">            pd.DataFrame:</span>
<span class="sd">                A merged dataframe with conflicts handled as described.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError:</span>
<span class="sd">                Raised if conflicts exist in same-index merges.</span>

<span class="sd">        Notes:</span>
<span class="sd">            * Conflicting indices and values are recorded for debugging.</span>
<span class="sd">            * Between-group merges automatically prioritize the dataframe with the broader index.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Copy the right DataFrame to rename conflict columns if needed</span>
        <span class="n">df_right_renamed</span> <span class="o">=</span> <span class="n">df_right</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">df_left_dropped</span> <span class="o">=</span> <span class="n">df_left</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># Find columns that exist in both DataFrames (excluding index columns).</span>
        <span class="n">common_cols</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">df_left</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">df_right</span><span class="o">.</span><span class="n">columns</span><span class="p">))</span>

        <span class="c1"># Temporarily merge to detect conflicting columns</span>
        <span class="n">merged_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">df_left</span><span class="p">,</span> <span class="n">df_right</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;inner&quot;</span><span class="p">,</span> <span class="n">left_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">right_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">suffixes</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="s2">&quot;_right&quot;</span><span class="p">))</span>

        <span class="c1"># Case1) merge the dataframes which have same indexing fields (within group(Step 2)) but has conflict col</span>
        <span class="k">if</span> <span class="n">same_group</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">conflict_indices</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">conflict_columns</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1"># Check each common column to see if there are any mismatched (conflicting) values</span>
            <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">common_cols</span><span class="p">:</span>
                <span class="c1"># Right side column has suffix &quot;_right&quot;</span>
                <span class="n">col_right</span> <span class="o">=</span> <span class="n">col</span> <span class="o">+</span> <span class="s2">&quot;_right&quot;</span>
                <span class="n">mismatch_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">merged_df</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">!=</span> <span class="n">merged_df</span><span class="p">[</span><span class="n">col_right</span><span class="p">])</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">merged_df</span><span class="p">[[</span><span class="n">col</span><span class="p">,</span> <span class="n">col_right</span><span class="p">]]</span><span class="o">.</span><span class="n">isna</span><span class="p">()</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">mismatch_mask</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                    <span class="c1"># Save the conflicting column and index</span>
                    <span class="n">conflict_columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>
                    <span class="n">conflict_indices</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">merged_df</span><span class="p">[</span><span class="n">mismatch_mask</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                    <span class="c1"># Rename conflicting column in the right DataFrame</span>
                    <span class="n">df_right_renamed</span><span class="o">=</span> <span class="n">df_right</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="n">col</span><span class="p">:</span><span class="n">col_right</span><span class="p">})</span>
            <span class="c1"># Combine two dataframe with keeping conflict fields.</span>
            <span class="n">combined_df</span> <span class="o">=</span> <span class="n">df_left</span><span class="o">.</span><span class="n">combine_first</span><span class="p">(</span><span class="n">df_right_renamed</span><span class="p">)</span>

            <span class="c1"># If any conflicts were found, log them and raise an error</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">conflict_columns</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">conflict_columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_right&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">conflict_columns</span><span class="p">]</span>
                <span class="n">errormessage</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;There is conflict columns. check columns: </span><span class="si">{</span><span class="n">conflict_columns</span><span class="si">}</span><span class="s2">. check dataset: </span><span class="si">{</span><span class="p">(</span><span class="n">df_left_name</span><span class="p">,</span><span class="n">df_right_name</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">conflict_indices</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">conflict_indices</span><span class="p">[</span><span class="n">col</span><span class="p">]:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">dfError</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dfError</span><span class="p">)]</span> <span class="o">=</span> <span class="p">[</span><span class="n">errorConfig</span><span class="o">.</span><span class="n">mergeFail</span><span class="p">,</span> <span class="s2">&quot;Conflict columns&quot;</span><span class="p">,</span> <span class="n">errormessage</span><span class="p">,</span> <span class="p">(</span><span class="n">df_left_name</span><span class="p">,</span><span class="n">df_right_name</span><span class="p">),</span> <span class="n">col</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="p">(</span><span class="n">merged_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">index</span><span class="p">,</span><span class="n">col</span><span class="p">],</span><span class="n">merged_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">index</span><span class="p">,</span><span class="n">col</span><span class="o">+</span><span class="s2">&quot;_right&quot;</span><span class="p">])]</span>

                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">errormessage</span><span class="p">)</span>

        <span class="c1"># Case2) merge the dataframes which have different indexing fields (between group(Step3)) but has conflict cols</span>
        <span class="k">if</span> <span class="n">same_group</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">common_cols</span><span class="p">:</span>
                <span class="c1"># Right side column has suffix &quot;_right&quot;</span>
                <span class="n">col_right</span> <span class="o">=</span> <span class="n">col</span> <span class="o">+</span> <span class="s2">&quot;_right&quot;</span>
                <span class="n">mismatch_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">merged_df</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">!=</span> <span class="n">merged_df</span><span class="p">[</span><span class="n">col_right</span><span class="p">])</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">merged_df</span><span class="p">[[</span><span class="n">col</span><span class="p">,</span> <span class="n">col_right</span><span class="p">]]</span><span class="o">.</span><span class="n">isna</span><span class="p">()</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">mismatch_mask</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                    <span class="c1"># Drop the conflicting column from df_left to favor df_right&#39;s version</span>
                    <span class="n">df_left_dropped</span><span class="o">=</span><span class="n">df_left</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">col</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="c1">#take the value from the large indexed one.</span>
            <span class="c1"># Combine two dataframe with keeping conflict field from the dataframe which has larger index.</span>
            <span class="n">combined_df</span> <span class="o">=</span> <span class="n">df_left_dropped</span><span class="o">.</span><span class="n">combine_first</span><span class="p">(</span><span class="n">df_right</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">combined_df</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_md_sort_dfs_by_index_count</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">dataframes</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">],</span>
        <span class="n">reverse</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sort dataset names by the number of index levels in their dataframes.</span>

<span class="sd">        Args:</span>
<span class="sd">            dataframes (dict[str, pd.DataFrame]):</span>
<span class="sd">                A dictionary mapping dataset names to their dataframes.</span>
<span class="sd">            reverse (bool, optional):</span>
<span class="sd">                If True, sort in descending order. Default is False (ascending).</span>

<span class="sd">        Returns:</span>
<span class="sd">            list[str]:</span>
<span class="sd">                Dataset names sorted by the count of index levels.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sorted_dataframes</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">dataframes</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">dataframes</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">names</span><span class="p">),</span> <span class="n">reverse</span><span class="o">=</span><span class="n">reverse</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sorted_dataframes</span>


    <span class="k">def</span><span class="w"> </span><span class="nf">_merge_file_location_fields</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Merge file location fields from all dataset metadata into a single list.</span>

<span class="sd">        This method consolidates the `fileLocationFieldList` entries from all datasets</span>
<span class="sd">        in `self.datadesc_dicts`, ensuring no `None` values are included.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list[str]:</span>
<span class="sd">                Combined list of file location fields from all datasets.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; file_fields = cohort._merge_file_location_fields()</span>
<span class="sd">            &gt;&gt;&gt; print(file_fields)</span>
<span class="sd">            [&#39;Image File&#39;, &#39;Mask File&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">merged_file_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">info</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">datadesc_dicts</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
            <span class="n">file_list</span> <span class="o">=</span> <span class="n">info</span><span class="p">[</span><span class="s2">&quot;fileLocationFieldList&quot;</span><span class="p">]</span>  <span class="c1"># Safe way to access key</span>
            <span class="k">if</span> <span class="n">file_list</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># Ensures it&#39;s not None</span>
                <span class="n">merged_file_list</span> <span class="o">=</span> <span class="p">[</span><span class="o">*</span><span class="n">merged_file_list</span><span class="p">,</span> <span class="o">*</span><span class="n">file_list</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">merged_file_list</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_filter_dataframe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">errorConfig</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Filter the cohort dataframe based on step 5 of initialization:</span>

<span class="sd">        1. Retain only indexing fields, mandatory fields, and optional fields.</span>
<span class="sd">        2. Drop rows where mandatory fields are empty (NaN).</span>
<span class="sd">        3. Exclude rows matching specified index values (`excludeEntriesList`).</span>
<span class="sd">        4. Apply query string filtering (`queryString`) if provided.</span>

<span class="sd">        Args:</span>
<span class="sd">            df (pd.DataFrame):</span>
<span class="sd">                The dataframe to filter, expected to be multi-indexed.</span>
<span class="sd">            errorConfig (ErrorConfig):</span>
<span class="sd">                Error configuration object used to log filtering errors.</span>

<span class="sd">        Returns:</span>
<span class="sd">            pd.DataFrame:</span>
<span class="sd">                The filtered dataframe with the same indexing structure restored.</span>

<span class="sd">        Raises:</span>
<span class="sd">            CohortError:</span>
<span class="sd">                Raised if filtering fails at any stage (columns/rows, exclusions, or query application).</span>

<span class="sd">        Notes:</span>
<span class="sd">            * Index levels are temporarily cast to strings during filtering and then restored to their original types.</span>
<span class="sd">            * Missing index values are replaced by `-1` during temporary type conversions.</span>
<span class="sd">            * Logs details about dropped rows and filtered columns for traceability.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">df_filtered</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># Save the format of index to revert in the final stage.</span>
        <span class="n">tmp_df</span> <span class="o">=</span> <span class="n">df_filtered</span><span class="p">[</span><span class="o">~</span><span class="n">df_filtered</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">to_frame</span><span class="p">()</span><span class="o">.</span><span class="n">isna</span><span class="p">()</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)]</span> <span class="c1"># filter the row by dropping missing index</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">tmp_df</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
            <span class="n">indexFormatDict</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">key</span><span class="p">:</span> <span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span>
                <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">tmp_df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">to_frame</span><span class="p">()</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Fallback to dtype information when no valid rows exist</span>
            <span class="n">indexFormatDict</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">name</span><span class="p">:</span> <span class="n">dtype</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">dtype</span> <span class="ow">in</span> <span class="n">df_filtered</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">to_frame</span><span class="p">()</span><span class="o">.</span><span class="n">dtypes</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="p">}</span>

        <span class="c1"># Convert all indices as string (only for filtering)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">df_filtered</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="p">):</span>
            <span class="n">df_filtered</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">df_filtered</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">set_levels</span><span class="p">(</span>
                <span class="p">[</span><span class="n">level</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">level</span> <span class="ow">in</span> <span class="n">df_filtered</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">levels</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">df_filtered</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">df_filtered</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">df</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
                <span class="c1"># 1. Column and row filtering by the mandatoryFieldList and optionalFieldList</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mandatoryFieldList</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">optionalFieldList</span><span class="p">:</span>
                    <span class="n">df_filtered</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fd_filter_cols_and_rows_by_specified_fields</span><span class="p">(</span><span class="n">df_filtered</span><span class="p">)</span>

                <span class="c1"># 2. Remove rows where indexing fields match values in `excludeEntriesList`</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">excludeEntriesList</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">df_filtered</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fd_exclude_entries_by_list</span><span class="p">(</span><span class="n">df_filtered</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Excluding entries failed: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                <span class="c1"># 3. Apply query string filtering (e.g., &quot;Age &gt; 65&quot;)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">queryString</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Input Query: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">queryString</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">df_filtered</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fd_filter_entires_by_query</span><span class="p">(</span><span class="n">df_filtered</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Query string failed: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1"># revert index as original format</span>
            <span class="n">index_df</span> <span class="o">=</span> <span class="n">df_filtered</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">to_frame</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">index_df</span> <span class="o">=</span> <span class="n">index_df</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">field</span><span class="p">,</span> <span class="n">dtype</span> <span class="ow">in</span> <span class="n">indexFormatDict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">index_df</span><span class="p">[</span><span class="n">field</span><span class="p">]</span> <span class="o">=</span> <span class="n">index_df</span><span class="p">[</span><span class="n">field</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>

            <span class="n">df_filtered</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_frame</span><span class="p">(</span><span class="n">index_df</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dfError</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dfError</span><span class="p">)]</span><span class="o">=</span><span class="p">[</span><span class="n">errorConfig</span><span class="o">.</span><span class="n">filteringFail</span><span class="p">,</span><span class="s2">&quot;Filtering Fail&quot;</span><span class="p">,</span><span class="n">e</span><span class="p">,</span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="s2">&quot;&quot;</span><span class="p">]</span>
            <span class="k">raise</span> <span class="n">CohortError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Failed to filter the data. </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dfError</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span>
        <span class="k">return</span> <span class="n">df_filtered</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_fd_filter_cols_and_rows_by_specified_fields</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Filter dataframe columns and rows using `mandatoryFieldList` and `optionalFieldList`.</span>

<span class="sd">        This method:</span>
<span class="sd">        1. Retains only columns listed in mandatory/optional fields and file location fields.</span>
<span class="sd">        2. Drops rows with missing values in mandatory fields.</span>

<span class="sd">        Args:</span>
<span class="sd">            df (pd.DataFrame):</span>
<span class="sd">                The dataframe to filter.</span>

<span class="sd">        Returns:</span>
<span class="sd">            pd.DataFrame:</span>
<span class="sd">                A dataframe containing only the specified fields and valid rows.</span>

<span class="sd">        Notes:</span>
<span class="sd">            * Updates `self.file_location_fields` to ensure alignment with retained fields.</span>
<span class="sd">            * Logs both column and row filtering operations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># 1. Assign columns to keep</span>
        <span class="n">keep_columns</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mandatoryFieldList</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">keep_columns</span> <span class="o">=</span> <span class="n">keep_columns</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mandatoryFieldList</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">optionalFieldList</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">keep_columns</span> <span class="o">=</span> <span class="n">keep_columns</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">optionalFieldList</span><span class="p">)</span>

        <span class="c1"># Save a dictionary with invalid keys removed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">file_location_fields</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">file_location_fields</span> <span class="k">if</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">keep_columns</span><span class="p">]</span>

        <span class="c1"># Save the key of file_location_fields in the keep column dictionary</span>
        <span class="n">keep_columns</span> <span class="o">=</span> <span class="n">keep_columns</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file_location_fields</span><span class="p">)</span>

        <span class="n">df_filtered</span> <span class="o">=</span> <span class="n">df</span><span class="p">[[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">keep_columns</span><span class="p">]]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;üîµ Filtered columns by mandatoryFieldList and optionalFieldList: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">keep_columns</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># 2. Drop rows where mandatory fields are empty</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mandatoryFieldList</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Input mandatoryFieldList: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">mandatoryFieldList</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">df_filtered</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mandatoryFieldList</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;üîµ Found rows to exclude by missing values on mandatoryFieldList: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">)</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">df_filtered</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;üîµ Filtered rows: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">df_filtered</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">df_filtered</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_fd_exclude_entries_by_list</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Exclude rows from the dataframe based on `excludeEntriesList`.</span>

<span class="sd">        Supports two exclusion modes:</span>

<span class="sd">        1. **Dictionary-based filtering:**  </span>
<span class="sd">           Remove rows where index levels match specified values.  </span>
<span class="sd">           Example: `{&#39;Patient ID&#39;: [&#39;P001&#39;], &#39;Study ID&#39;: [&#39;S01&#39;]}`  </span>

<span class="sd">        2. **List-based filtering:**  </span>
<span class="sd">           Remove rows by providing exact multi-index tuples.  </span>
<span class="sd">           Example: `[(&#39;P001&#39;, &#39;S01&#39;), (&#39;P002&#39;, &#39;S02&#39;)]`</span>

<span class="sd">        Args:</span>
<span class="sd">            df (pd.DataFrame):</span>
<span class="sd">                The multi-index dataframe to filter.</span>

<span class="sd">        Returns:</span>
<span class="sd">            pd.DataFrame:</span>
<span class="sd">                Dataframe with rows excluded per the specified conditions.</span>

<span class="sd">        Notes:</span>
<span class="sd">            * Logs the number of rows excluded for traceability.</span>
<span class="sd">            * Dictionary mode combines conditions with OR logic (rows matching any condition are excluded).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Input excludeEntriesList: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">excludeEntriesList</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">excludeEntriesList</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="c1"># Initialize a boolean mask for rows to drop</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>

            <span class="c1"># Combine conditions to create a mask</span>
            <span class="k">for</span> <span class="n">level</span><span class="p">,</span> <span class="n">values</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">excludeEntriesList</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">mask</span> <span class="o">|=</span> <span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_level_values</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">)</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

            <span class="c1"># Apply inverse mask to remove matching rows</span>
            <span class="n">df_exclude</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="o">~</span><span class="n">mask</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">excludeEntriesList</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">df_exclude</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">excludeEntriesList</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;üîµ Found rows to exclude by excludeEntriesList: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="n">df_exclude</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;üîµ Filtered rows: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">df_exclude</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">df_exclude</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_fd_filter_entires_by_query</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Filter rows in the dataframe using a query string.</span>

<span class="sd">        Args:</span>
<span class="sd">            df (pd.DataFrame):</span>
<span class="sd">                The dataframe to filter.</span>

<span class="sd">        Returns:</span>
<span class="sd">            pd.DataFrame:</span>
<span class="sd">                Filtered dataframe containing only rows satisfying the query condition.</span>

<span class="sd">        Notes:</span>
<span class="sd">            * Query strings follow Pandas `.query()` syntax.</span>
<span class="sd">            * Default engine is `python` for compatibility.</span>
<span class="sd">            * Logs the number of rows filtered and excluded.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;üîµ Found rows to exclude by queryString: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">)</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">queryString</span><span class="p">,</span><span class="n">engine</span><span class="o">=</span><span class="s1">&#39;python&#39;</span><span class="p">))</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">df_filtered</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">queryString</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;üîµ Filtered rows: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">df_filtered</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">df_filtered</span></div>


</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Hye-Lim LEE (Epione team, Inria).</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>